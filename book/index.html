<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="wangzhengtai"><title>图书记录 | 落叶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">图书记录</h1><a id="logo" href="/.">落叶</a><p class="description">总以为事情都是慢慢来的，但却有很多的事，却是悄然而至，一瞬间便变了！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a class="current" href="/book/"><i class="fa fa-book"> 图书</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">图书记录</h1><div class="post-content"><style>
    blockquote {
        border-left: 0.4em solid #fff;
        margin: 0.4em 0;
        color: #434343;
        min-height: 0;
        padding: 0 0 0 15px;
    }

    /* details {
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: 0.5em 0.5em 0;
    }

    summary {
        font-weight: bold;
        margin: -0.5em -0.5em 0;
        padding: 0.5em;
    }

    details[open] {
        padding: 0.5em;
    }

    details[open] summary {
        border-bottom: 1px solid #aaa;
        margin-bottom: 0.5em;
    } */
</style>

<script>
    var isOpen = false;

    function expandOrScale() {
        if (isOpen){
            isOpen = false;
        } else {
            isOpen = true;
        }

        document.querySelectorAll('details').forEach(item => {
            if (isOpen) {
                item.open = true;
            } else {
                item.open = false;
            }
        })

        var button = document.getElementById("expand_scale");
        if (isOpen) {
            button.innerText = "一键缩放";
        } else {
            button.innerText = "一键展开";
        }
    }
</script>

<p>从大学以来，陆陆续续买了很多的书，但大多书都蒙尘了，很多时候自己都不知道自己有这一本书，特此在这里记录一下。</p>
<p><button id="expand_scale" onclick="expandOrScale()">一键展开</button></p>
<h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul>
<li>《C Primer Plus（第6版）中文版 : 第六版》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章 初识C语言 1</summary>
          <blockquote>
          1.1 C语言的起源 1</br>
          <details>
          <summary>1.2 选择C语言的理由 1</summary>
              <blockquote>
              1.2.1 设计特性 1</br>
              1.2.2 高效性 1</br>
              1.2.3 可移植性 2</br>
              1.2.4 强大而灵活 3</br>
              1.2.5 面向程序员 3</br>
              1.2.6 缺点 3</br>
              </blockquote>
          </details>
          1.3 C语言的应用范围 3</br>
          1.4 计算机能做什么 4</br>
          1.5 高级计算机语言和编译器 5</br>
          <details>
          <summary>1.6 语言标准 6</summary>
              <blockquote>
              1.6.1 第1个ANSI/ISO C标准 6</br>
              1.6.2 C99标准 6</br>
              1.6.3 C11标准 7</br>
              </blockquote>
          </details>
          <details>
          <summary>1.7 使用C语言的7个步骤 7</summary>
              <blockquote>
              1.7.1 第1步：定义程序的目标 8</br>
              1.7.2 第2步：设计程序 8</br>
              1.7.3 第3步：编写代码 8</br>
              1.7.4 第4步：编译 8</br>
              1.7.5 第5步：运行程序 9</br>
              1.7.6 第6步：测试和调试程序 9</br>
              1.7.7 第7步：维护和修改代码 9</br>
              1.7.8 说明 9</br>
              </blockquote>
          </details>
          <details>
          <summary>1.8 编程机制 10</summary>
              <blockquote>
              1.8.1 目标代码文件、可执行文件和库 10</br>
              1.8.2 UNIX系统 11</br>
              1.8.3 GNU编译器集合和LLVM项目 13</br>
              1.8.4 Linux系统 13</br>
              1.8.5 PC的命令行编译器 14</br>
              1.8.6 集成开发环境（Windows） 14</br>
              1.8.7 Windows/Linux 15</br>
              1.8.8 Macintosh中的C 15</br>
              </blockquote>
          </details>
          1.9 本书的组织结构 15</br>
          <details>
          <summary>1.10 本书的约定 16</summary>
              <blockquote>
              1.10.1 字体 16</br>
              1.10.2 程序输出 16</br>
              1.10.3 特殊元素 17</br>
              </blockquote>
          </details>
          1.11 本章小结 17</br>
          1.12 复习题 18</br>
          1.13 编程练习 18</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章 C语言概述 19</summary>
          <blockquote>
          2.1 简单的C程序示例 19</br>
          <details>
          <summary>2.2 示例解释 20</summary>
              <blockquote>
              2.2.1 第1遍：快速概要 21</br>
              2.2.2 第2遍：程序细节 21</br>
              </blockquote>
          </details>
          2.3 简单程序的结构 28</br>
          2.4 提高程序可读性的技巧 28</br>
          <details>
          <summary>2.5 进一步使用C 29</summary>
              <blockquote>
              2.5.1 程序说明 30</br>
              2.5.2 多条声明 30</br>
              2.5.3 乘法 30</br>
              2.5.4 打印多个值 30</br>
              </blockquote>
          </details>
          2.6 多个函数 30</br>
          <details>
          <summary>2.7 调试程序 32</summary>
              <blockquote>
              2.7.1 语法错误 32</br>
              2.7.2 语义错误 33</br>
              2.7.3 程序状态 34</br>
              </blockquote>
          </details>
          2.8 关键字和保留标识符 34</br>
          2.9 关键概念 35</br>
          2.10 本章小结 35</br>
          2.11 复习题 36</br>
          2.12 编程练习 37</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章 数据和C 39</summary>
          <blockquote>
          3.1 示例程序 39</br>
          3.2 变量与常量数据 42</br>
          <details>
          <summary>3.3 数据：数据类型关键字 42</summary>
              <blockquote>
              3.3.1 整数和浮点数 43</br>
              3.3.2 整数 43</br>
              3.3.3 浮点数 43</br>
              </blockquote>
          </details>
          <details>
          <summary>3.4 C语言基本数据类型 44</summary>
              <blockquote>
              3.4.1 int类型 44</br>
              3.4.2 其他整数类型 47</br>
              3.4.3 使用字符：char类型 50</br>
              3.4.4 _Bool类型 54</br>
              3.4.5 可移植类型：stdint.h和inttypes.h 55</br>
              3.4.6 float、double和long double 56</br>
              3.4.7 复数和虚数类型 60</br>
              3.4.8 其他类型 60</br>
              3.4.9 类型大小 62</br>
              </blockquote>
          </details>
          3.5 使用数据类型 63</br>
          3.6 参数和陷阱 63</br>
          <details>
          <summary>3.7 转义序列示例 64</summary>
              <blockquote>
              3.7.1 程序运行情况 65</br>
              3.7.2 刷新输出 65</br>
              </blockquote>
          </details>
          3.8 关键概念 66</br>
          3.9 本章小结 66</br>
          3.10 复习题 67</br>
          3.11 编程练习 68</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章 字符串和格式化输入/输出 71</summary>
          <blockquote>
          4.1 前导程序 71</br>
          <details>
          <summary>4.2 字符串简介 72</summary>
              <blockquote>
              4.2.1 char类型数组和null字符 72</br>
              4.2.2 使用字符串 73</br>
              4.2.3 strlen()函数 74</br>
              </blockquote>
          </details>
          <details>
          <summary>4.3 常量和C预处理器 76</summary>
              <blockquote>
              4.3.1 const限定符 78</br>
              4.3.2 明示常量 78</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4 printf()和scanf() 80</summary>
              <blockquote>
              4.4.1 printf()函数 80</br>
              4.4.2 使用printf() 81</br>
              4.4.3 printf()的转换说明修饰符 83</br>
              4.4.4 转换说明的意义 87</br>
              4.4.5 使用scanf() 92</br>
              4.4.6 printf()和scanf()的*修饰符 95</br>
              4.4.7 printf()的用法提示 97</br>
              </blockquote>
          </details>
          4.5 关键概念 98</br>
          4.6 本章小结 98</br>
          4.7 复习题 99</br>
          4.8 编程练习 100</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章 运算符、表达式和语句 103</summary>
          <blockquote>
          5.1 循环简介 103</br>
          <details>
          <summary>5.2 基本运算符 105</summary>
              <blockquote>
              5.2.1 赋值运算符：= 105</br>
              5.2.2 加法运算符：+ 107</br>
              5.2.3 减法运算符：- 107</br>
              5.2.4 符号运算符：-和+ 107</br>
              5.2.5 乘法运算符：* 108</br>
              5.2.6 除法运算符：/ 110</br>
              5.2.7 运算符优先级 110</br>
              5.2.8 优先级和求值顺序 112</br>
              </blockquote>
          </details>
          <details>
          <summary>5.3 其他运算符 113</summary>
              <blockquote>
              5.3.1 sizeof运算符和size_t类型 113</br>
              5.3.2 求模运算符：% 114</br>
              5.3.3 递增运算符：++ 115</br>
              5.3.4 递减运算符：-- 118</br>
              5.3.5 优先级 118</br>
              5.3.6 不要自作聪明 119</br>
              </blockquote>
          </details>
          <details>
          <summary>5.4 表达式和语句 120</summary>
              <blockquote>
              5.4.1 表达式 120</br>
              5.4.2 语句 120</br>
              5.4.3 复合语句（块） 123</br>
              </blockquote>
          </details>
          5.5 类型转换 124</br>
          5.6 带参数的函数 127</br>
          5.7 示例程序 129</br>
          5.8 关键概念 130</br>
          5.9 本章小结 130</br>
          5.10 复习题 131</br>
          5.11 编程练习 134</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章 C控制语句：循环 137</summary>
          <blockquote>
          <details>
          <summary>6.1 再探while循环 137</summary>
              <blockquote>
              6.1.1 程序注释 138</br>
              6.1.2 C风格读取循环 139</br>
              </blockquote>
          </details>
          <details>
          <summary>6.2 while语句 140</summary>
              <blockquote>
              6.2.1 终止while循环 140</br>
              6.2.2 何时终止循环 141</br>
              6.2.3 while：入口条件循环 141</br>
              6.2.4 语法要点 141</br>
              </blockquote>
          </details>
          <details>
          <summary>6.3 用关系运算符和表达式比较大小 143</summary>
              <blockquote>
              6.3.1 什么是真 144</br>
              6.3.2 其他真值 145</br>
              6.3.3 真值的问题 146</br>
              6.3.4 新的_Bool类型 147</br>
              6.3.5 优先级和关系运算符 148</br>
              </blockquote>
          </details>
          6.4 不确定循环和计数循环 150</br>
          6.5 for循环 151</br>
          6.6 其他赋值运算符：+=、-=、*=、/=、%= 155</br>
          6.7 逗号运算符 156</br>
          6.8 出口条件循环：do while 159</br>
          6.9 如何选择循环 161</br>
          <details>
          <summary>6.10 嵌套循环 162</summary>
              <blockquote>
              6.10.1 程序分析 163</br>
              6.10.2 嵌套变式 163</br>
              </blockquote>
          </details>
          6.11 数组简介 164</br>
          <details>
          <summary>6.12 使用函数返回值的循环示例 166</summary>
              <blockquote>
              6.12.1 程序分析 168</br>
              6.12.2 使用带返回值的函数 169</br>
              </blockquote>
          </details>
          6.13 关键概念 169</br>
          6.14 本章小结 170</br>
          6.15 复习题 170</br>
          6.16 编程练习 174</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章 C控制语句：分支和跳转 177</summary>
          <blockquote>
          7.1 if语句 177</br>
          <details>
          <summary>7.2 if else语句 179</summary>
              <blockquote>
              7.2.1 另一个示例：介绍getchar()和putchar() 180</br>
              7.2.2 ctype.h系列的字符函数 182</br>
              7.2.3 多重选择else if 184</br>
              7.2.4 else与if配对 186</br>
              7.2.5 多层嵌套的if语句 187</br>
              </blockquote>
          </details>
          <details>
          <summary>7.3 逻辑运算符 190</summary>
              <blockquote>
              7.3.1 备选拼写：iso646.h头文件 191</br>
              7.3.2 优先级 192</br>
              7.3.3 求值顺序 192</br>
              7.3.4 范围 193</br>
              </blockquote>
          </details>
          7.4 一个统计单词的程序 194</br>
          7.5 条件运算符：?： 196</br>
          <details>
          <summary>7.6 循环辅助：continue和break 198</summary>
              <blockquote>
              7.6.1 continue语句 198</br>
              7.6.2 break语句 200</br>
              </blockquote>
          </details>
          <details>
          <summary>7.7 多重选择：switch和break 202</summary>
              <blockquote>
              7.7.1 switch语句 204</br>
              7.7.2 只读每行的首字符 205</br>
              7.7.3 多重标签 206</br>
              7.7.4 switch和if else 208</br>
              </blockquote>
          </details>
          7.8 goto语句 208</br>
          7.9 关键概念 211</br>
          7.10 本章小结 211</br>
          7.11 复习题 212</br>
          7.12 编程练习 214</br>
          </blockquote>
      </details>
      <details>
      <summary>第8章 字符输入/输出和输入验证 217</summary>
          <blockquote>
          8.1 单字符I/O：getchar()和putchar() 217</br>
          8.2 缓冲区 218</br>
          <details>
          <summary>8.3 结束键盘输入 219</summary>
              <blockquote>
              8.3.1 文件、流和键盘输入 219</br>
              8.3.2 文件结尾 220</br>
              </blockquote>
          </details>
          8.4 重定向和文件 222</br>
          <details>
          <summary>8.5 创建更友好的用户界面 226</summary>
              <blockquote>
              8.5.1 使用缓冲输入 226</br>
              8.5.2 混合数值和字符输入 228</br>
              </blockquote>
          </details>
          <details>
          <summary>8.6 输入验证 230</summary>
              <blockquote>
              8.6.1 分析程序 234</br>
              8.6.2 输入流和数字 234</br>
              </blockquote>
          </details>
          <details>
          <summary>8.7 菜单浏览 235</summary>
              <blockquote>
              8.7.1 任务 235</br>
              8.7.2 使执行更顺利 235</br>
              8.7.3 混合字符和数值输入 237</br>
              </blockquote>
          </details>
          8.8 关键概念 240</br>
          8.9 本章小结 240</br>
          8.10 复习题 241</br>
          8.11 编程练习 241</br>
          </blockquote>
      </details>
      <details>
      <summary>第9章 函数 243</summary>
          <blockquote>
          <details>
          <summary>9.1 复习函数 243</summary>
              <blockquote>
              9.1.1 创建并使用简单函数 244</br>
              9.1.2 分析程序 245</br>
              9.1.3 函数参数 247</br>
              9.1.4 定义带形式参数的函数 248</br>
              9.1.5 声明带形式参数函数的原型 249</br>
              9.1.6 调用带实际参数的函数 249</br>
              9.1.7 黑盒视角 250</br>
              9.1.8 使用return从函数中返回值 250</br>
              9.1.9 函数类型 252</br>
              </blockquote>
          </details>
          <details>
          <summary>9.2 ANSI C函数原型 253</summary>
              <blockquote>
              9.2.1 问题所在 253</br>
              9.2.2 ANSI的解决方案 254</br>
              9.2.3 无参数和未指定参数 255</br>
              9.2.4 函数原型的优点 256</br>
              </blockquote>
          </details>
          <details>
          <summary>9.3 递归 256</summary>
              <blockquote>
              9.3.1 演示递归 256</br>
              9.3.2 递归的基本原理 258</br>
              9.3.3 尾递归 258</br>
              9.3.4 递归和倒序计算 260</br>
              9.3.5 递归的优缺点 262</br>
              </blockquote>
          </details>
          <details>
          <summary>9.4 编译多源代码文件的程序 262</summary>
              <blockquote>
              9.4.1 UNIX 263</br>
              9.4.2 Linux 263</br>
              9.4.3 DOS命令行编译器 263</br>
              9.4.4 Windows和苹果的IDE编译器 263</br>
              9.4.5 使用头文件 263</br>
              </blockquote>
          </details>
          9.5 查找地址：&运算符 267</br>
          9.6 更改主调函数中的变量 268</br>
          <details>
          <summary>9.7 指针简介 269</summary>
              <blockquote>
              9.7.1 间接运算符：* 270</br>
              9.7.2 声明指针 270</br>
              9.7.3 使用指针在函数间通信 271</br>
              </blockquote>
          </details>
          9.8 关键概念 274</br>
          9.9 本章小结 275</br>
          9.10 复习题 275</br>
          9.11 编程练习 276</br>
          </blockquote>
      </details>
      <details>
      <summary>第10章 数组和指针 277</summary>
          <blockquote>
          <details>
          <summary>10.1 数组 277</summary>
              <blockquote>
              10.1.1 初始化数组 277</br>
              10.1.2 指定初始化器（C99） 281</br>
              10.1.3 给数组元素赋值 282</br>
              10.1.4 数组边界 282</br>
              10.1.5 指定数组的大小 284</br>
              </blockquote>
          </details>
          <details>
          <summary>10.2 多维数组 284</summary>
              <blockquote>
              10.2.1 初始化二维数组 287</br>
              10.2.2 其他多维数组 288</br>
              </blockquote>
          </details>
          10.3 指针和数组 288</br>
          <details>
          <summary>10.4 函数、数组和指针 290</summary>
              <blockquote>
              10.4.1 使用指针形参 293</br>
              10.4.2 指针表示法和数组表示法 294</br>
              </blockquote>
          </details>
          10.5 指针操作 295</br>
          <details>
          <summary>10.6 保护数组中的数据 298</summary>
              <blockquote>
              10.6.1 对形式参数使用const 299</br>
              10.6.2 const的其他内容 300</br>
              </blockquote>
          </details>
          <details>
          <summary>10.7 指针和多维数组 302</summary>
              <blockquote>
              10.7.1 指向多维数组的指针 304</br>
              10.7.2 指针的兼容性 305</br>
              10.7.3 函数和多维数组 306</br>
              </blockquote>
          </details>
          10.8 变长数组（VLA） 309</br>
          10.9 复合字面量 312</br>
          10.10 关键概念 314</br>
          10.11 本章小结 315</br>
          10.12 复习题 316</br>
          10.13 编程练习 317</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章 字符串和字符串函数 321</summary>
          <blockquote>
          <details>
          <summary>11.1 表示字符串和字符串I/O 321</summary>
              <blockquote>
              11.1.1 在程序中定义字符串 322</br>
              11.1.2 指针和字符串 328</br>
              </blockquote>
          </details>
          <details>
          <summary>11.2 字符串输入 329</summary>
              <blockquote>
              11.2.1 分配空间 329</br>
              11.2.2 不幸的gets()函数 330</br>
              11.2.3 gets()的替代品 331</br>
              11.2.4 scanf()函数 336</br>
              </blockquote>
          </details>
          <details>
          <summary>11.3 字符串输出 337</summary>
              <blockquote>
              11.3.1 puts()函数 338</br>
              11.3.2 fputs()函数 339</br>
              11.3.3 printf()函数 339</br>
              </blockquote>
          </details>
          11.4 自定义输入/输出函数 340</br>
          <details>
          <summary>11.5 字符串函数 342</summary>
              <blockquote>
              11.5.1 strlen()函数 342</br>
              11.5.2 strcat()函数 343</br>
              11.5.3 strncat()函数 345</br>
              11.5.4 strcmp()函数 346</br>
              11.5.5 strcpy()和strncpy()函数 351</br>
              11.5.6 sprintf()函数 356</br>
              11.5.7 其他字符串函数 357</br>
              </blockquote>
          </details>
          <details>
          <summary>11.6 字符串示例：字符串排序 359</summary>
              <blockquote>
              11.6.1 排序指针而非字符串 360</br>
              11.6.2 选择排序算法 361</br>
              </blockquote>
          </details>
          11.7 ctype.h字符函数和字符串 362</br>
          <details>
          <summary>11.8 命令行参数 363</summary>
              <blockquote>
              11.8.1 集成环境中的命令行参数 365</br>
              11.8.2 Macintosh中的命令行参数 365</br>
              </blockquote>
          </details>
          11.9 把字符串转换为数字 365</br>
          11.10 关键概念 368</br>
          11.11 本章小结 368</br>
          11.12 复习题 369</br>
          11.13 编程练习 371</br>
          </blockquote>
      </details>
      <details>
      <summary>第12章 存储类别、链接和内存管理 373</summary>
          <blockquote>
          <details>
          <summary>12.1 存储类别 373</summary>
              <blockquote>
              12.1.1 作用域 374</br>
              12.1.2 链接 376</br>
              12.1.3 存储期 376</br>
              12.1.4 自动变量 377</br>
              12.1.5 寄存器变量 380</br>
              12.1.6 块作用域的静态变量 381</br>
              12.1.7 外部链接的静态变量 382</br>
              12.1.8 内部链接的静态变量 386</br>
              12.1.9 多文件 386</br>
              12.1.10 存储类别说明符 387</br>
              12.1.11 存储类别和函数 389</br>
              12.1.12 存储类别的选择 389</br>
              </blockquote>
          </details>
          12.2 随机数函数和静态变量 390</br>
          12.3 掷骰子 393</br>
          <details>
          <summary>12.4 分配内存：malloc()和free() 396</summary>
              <blockquote>
              12.4.1 free()的重要性 399</br>
              12.4.2 calloc()函数 400</br>
              12.4.3 动态内存分配和变长数组 400</br>
              12.4.4 存储类别和动态内存分配 401</br>
              </blockquote>
          </details>
          <details>
          <summary>12.5 ANSI C类型限定符 402</summary>
              <blockquote>
              12.5.1 const类型限定符 403</br>
              12.5.2 volatile类型限定符 404</br>
              12.5.3 restrict类型限定符 405</br>
              12.5.4 _Atomic类型限定符（C11） 406</br>
              12.5.5 旧关键字的新位置 406</br>
              </blockquote>
          </details>
          12.6 关键概念 407</br>
          12.7 本章小结 407</br>
          12.8 复习题 408</br>
          12.9 编程练习 409</br>
          </blockquote>
      </details>
      <details>
      <summary>第13章 文件输入/输出 413</summary>
          <blockquote>
          <details>
          <summary>13.1 与文件进行通信 413</summary>
              <blockquote>
              13.1.1 文件是什么 413</br>
              13.1.2 文本模式和二进制模式 413</br>
              13.1.3 I/O的级别 415</br>
              13.1.4 标准文件 415</br>
              </blockquote>
          </details>
          <details>
          <summary>13.2 标准I/O 415</summary>
              <blockquote>
              13.2.1 检查命令行参数 416</br>
              13.2.2 fopen()函数 416</br>
              13.2.3 getc()和putc()函数 417</br>
              13.2.4 文件结尾 418</br>
              13.2.5 fclose()函数 419</br>
              13.2.6 指向标准文件的指针 419</br>
              </blockquote>
          </details>
          13.3 一个简单的文件压缩程序 419</br>
          <details>
          <summary>13.4 文件I/O：fprintf()、fscanf()、fgets()和fputs() 421</summary>
              <blockquote>
              13.4.1 fprintf()和fscanf()函数 421</br>
              13.4.2 fgets()和fputs()函数 422</br>
              </blockquote>
          </details>
          <details>
          <summary>13.5 随机访问：fseek()和ftell() 423</summary>
              <blockquote>
              13.5.1 fseek()和ftell()的工作原理 424</br>
              13.5.2 二进制模式和文本模式 425</br>
              13.5.3 可移植性 425</br>
              13.5.4 fgetpos()和fsetpos()函数 426</br>
              </blockquote>
          </details>
          13.6 标准I/O的机理 426</br>
          <details>
          <summary>13.7 其他标准I/O函数 427</summary>
              <blockquote>
              13.7.1 int ungetc(int c， FILE *fp)函数 427</br>
              13.7.2 int fflush()函数 428</br>
              13.7.3 int setvbuf()函数 428</br>
              13.7.4 二进制I/O：fread()和fwrite() 428</br>
              13.7.5 size_t fwrite()函数 429</br>
              13.7.6 size_t fread()函数 430</br>
              13.7.7 int feof(FILE *fp)和int ferror(FILE *fp)函数 430</br>
              13.7.8 一个程序示例 430</br>
              13.7.9 用二进制I/O进行随机访问 433</br>
              </blockquote>
          </details>
          13.8 关键概念 435</br>
          13.9 本章小结 435</br>
          13.10 复习题 435</br>
          13.11 编程练习 437</br>
          </blockquote>
      </details>
      <details>
      <summary>第14章 结构和其他数据形式 439</summary>
          <blockquote>
          14.1 示例问题：创建图书目录 439</br>
          14.2 建立结构声明 441</br>
          <details>
          <summary>14.3 定义结构变量 441</summary>
              <blockquote>
              14.3.1 初始化结构 442</br>
              14.3.2 访问结构成员 443</br>
              14.3.3 结构的初始化器 443</br>
              </blockquote>
          </details>
          <details>
          <summary>14.4 结构数组 444</summary>
              <blockquote>
              14.4.1 声明结构数组 446</br>
              14.4.2 标识结构数组的成员 447</br>
              14.4.3 程序讨论 447</br>
              </blockquote>
          </details>
          14.5 嵌套结构 448</br>
          <details>
          <summary>14.6 指向结构的指针 449</summary>
              <blockquote>
              14.6.1 声明和初始化结构指针 450</br>
              14.6.2 用指针访问成员 451</br>
              </blockquote>
          </details>
          <details>
          <summary>14.7 向函数传递结构的信息 451</summary>
              <blockquote>
              14.7.1 传递结构成员 451</br>
              14.7.2 传递结构的地址 452</br>
              14.7.3 传递结构 453</br>
              14.7.4 其他结构特性 454</br>
              14.7.5 结构和结构指针的选择 458</br>
              14.7.6 结构中的字符数组和字符指针 458</br>
              14.7.7 结构、指针和malloc() 459</br>
              14.7.8 复合字面量和结构（C99） 462</br>
              14.7.9 伸缩型数组成员（C99） 463</br>
              14.7.10 匿名结构（C11） 465</br>
              14.7.11 使用结构数组的函数 466</br>
              </blockquote>
          </details>
          <details>
          <summary>14.8 把结构内容保存到文件中 467</summary>
              <blockquote>
              14.8.1 保存结构的程序示例 468</br>
              14.8.2 程序要点 470</br>
              </blockquote>
          </details>
          14.9 链式结构 471</br>
          <details>
          <summary>14.10 联合简介 472</summary>
              <blockquote>
              14.10.1 使用联合 472</br>
              14.10.2 匿名联合（C11） 473</br>
              </blockquote>
          </details>
          <details>
          <summary>14.11 枚举类型 474</summary>
              <blockquote>
              14.11.1 enum常量 475</br>
              14.11.2 默认值 475</br>
              14.11.3 赋值 475</br>
              14.11.4 enum的用法 476</br>
              14.11.5 共享名称空间 477</br>
              </blockquote>
          </details>
          14.12 typedef简介 478</br>
          14.13 其他复杂的声明 479</br>
          14.14 函数和指针 481</br>
          14.15 关键概念 487</br>
          14.16 本章小结 487</br>
          14.17 复习题 488</br>
          14.18 编程练习 490</br>
          </blockquote>
      </details>
      <details>
      <summary>第15章 位操作 493</summary>
          <blockquote>
          <details>
          <summary>15.1 二进制数、位和字节 493</summary>
              <blockquote>
              15.1.1 二进制整数 494</br>
              15.1.2 有符号整数 494</br>
              15.1.3 二进制浮点数 495</br>
              </blockquote>
          </details>
          <details>
          <summary>15.2 其他进制数 495</summary>
              <blockquote>
              15.2.1 八进制 495</br>
              15.2.2 十六进制 496</br>
              </blockquote>
          </details>
          <details>
          <summary>15.3 C按位运算符 496</summary>
              <blockquote>
              15.3.1 按位逻辑运算符 497</br>
              15.3.2 用法：掩码 498</br>
              15.3.3 用法：打开位（设置位） 498</br>
              15.3.4 用法：关闭位（清空位） 499</br>
              15.3.5 用法：切换位 499</br>
              15.3.6 用法：检查位的值 500</br>
              15.3.7 移位运算符 500</br>
              15.3.8 编程示例 501</br>
              15.3.9 另一个例子 503</br>
              </blockquote>
          </details>
          <details>
          <summary>15.4 位字段 505</summary>
              <blockquote>
              15.4.1 位字段示例 506</br>
              15.4.2 位字段和按位运算符 509</br>
              </blockquote>
          </details>
          15.5 对齐特性（C11） 515</br>
          15.6 关键概念 516</br>
          15.7 本章小结 516</br>
          15.8 复习题 517</br>
          15.9 编程练习 518</br>
          </blockquote>
      </details>
      <details>
      <summary>第16章 C预处理器和C库 521</summary>
          <blockquote>
          16.1 翻译程序的第一步 521</br>
          <details>
          <summary>16.2 明示常量：#define 522</summary>
              <blockquote>
              16.2.1 记号 525</br>
              16.2.2 重定义常量 525</br>
              </blockquote>
          </details>
          <details>
          <summary>16.3 在#define中使用参数 525</summary>
              <blockquote>
              16.3.1 用宏参数创建字符串：#运算符 527</br>
              16.3.2 预处理器黏合剂：##运算符 528</br>
              16.3.3 变参宏：...和_ _VA_ARGS_ _ 529</br>
              </blockquote>
          </details>
          16.4 宏和函数的选择 530</br>
          <details>
          <summary>16.5 文件包含：#include 531</summary>
              <blockquote>
              16.5.1 头文件示例 531</br>
              16.5.2 使用头文件 533</br>
              </blockquote>
          </details>
          <details>
          <summary>16.6 其他指令 534</summary>
              <blockquote>
              16.6.1 #undef指令 534</br>
              16.6.2 从C预处理器角度看已定义 534</br>
              16.6.3 条件编译 535</br>
              16.6.4 预定义宏 539</br>
              16.6.5 #line和#error 540</br>
              16.6.6 #pragma 540</br>
              16.6.7 泛型选择（C11） 541</br>
              </blockquote>
          </details>
          16.7 内联函数（C99） 542</br>
          16.8 _Noreturn函数（C11） 544</br>
          <details>
          <summary>16.9 C库 544</summary>
              <blockquote>
              16.9.1 访问C库 544</br>
              16.9.2 使用库描述 545</br>
              </blockquote>
          </details>
          <details>
          <summary>16.10 数学库 546</summary>
              <blockquote>
              16.10.1 三角问题 547</br>
              16.10.2 类型变体 548</br>
              16.10.3 tgmath.h库（C99） 550</br>
              </blockquote>
          </details>
          <details>
          <summary>16.11 通用工具库 550</summary>
              <blockquote>
              16.11.1 exit()和atexit()函数 550</br>
              16.11.2 qsort()函数 552</br>
              </blockquote>
          </details>
          <details>
          <summary>16.12 断言库 556</summary>
              <blockquote>
              16.12.1 assert的用法 556</br>
              16.12.2 _Static_assert（C11） 557</br>
              </blockquote>
          </details>
          16.13 string.h库中的memcpy()和memmove() 558</br>
          16.14 可变参数：stdarg.h 560</br>
          16.15 关键概念 562</br>
          16.16 本章小结 562</br>
          16.17 复习题 562</br>
          16.18 编程练习 563</br>
          </blockquote>
      </details>
      <details>
      <summary>第17章 高级数据表示 567</summary>
          <blockquote>
          17.1 研究数据表示 567</br>
          <details>
          <summary>17.2 从数组到链表 570</summary>
              <blockquote>
              17.2.1 使用链表 572</br>
              17.2.2 反思 576</br>
              </blockquote>
          </details>
          <details>
          <summary>17.3 抽象数据类型（ADT） 576</summary>
              <blockquote>
              17.3.1 建立抽象 577</br>
              17.3.2 建立接口 578</br>
              17.3.3 使用接口 581</br>
              17.3.4 实现接口 583</br>
              </blockquote>
          </details>
          <details>
          <summary>17.4 队列ADT 589</summary>
              <blockquote>
              17.4.1 定义队列抽象数据类型 590</br>
              17.4.2 定义一个接口 590</br>
              17.4.3 实现接口数据表示 591</br>
              17.4.4 测试队列 598</br>
              </blockquote>
          </details>
          17.5 用队列进行模拟 600</br>
          17.6 链表和数组 605</br>
          <details>
          <summary>17.7 二叉查找树 608</summary>
              <blockquote>
              17.7.1 二叉树ADT 608</br>
              17.7.2 二叉查找树接口 609</br>
              17.7.3 二叉树的实现 611</br>
              17.7.4 使用二叉树 624</br>
              17.7.5 树的思想 628</br>
              </blockquote>
          </details>
          17.8 其他说明 629</br>
          17.9 关键概念 630</br>
          17.10 本章小结 630</br>
          17.11 复习题 630</br>
          17.12 编程练习 631</br>
          </blockquote>
      </details>
      附录A 复习题答案 633</br>
      <details>
          <summary>附录B 参考资料 665</summary>
              <blockquote>
              B.1 参考资料I：补充阅读 665</br>
              B.2 参考资料II：C运算符 667</br>
              B.3 参考资料III：基本类型和存储类别 671</br>
              B.4 参考资料IV：表达式、语句和程序流 675</br>
              B.5 参考资料V：新增C99和C11的ANSI C库 679</br>
              B.6 参考资料VI：扩展的整数类型 714</br>
              B.7 参考资料VII：扩展字符支持 716</br>
              B.8 参考资料VIII：C99/C11数值计算增强 720</br>
              B.9 参考资料IX：C和C++的区别 726</br>
              </blockquote>
          </details>
      </blockquote>
  </details></li>
<li>《C++ Primer Plus : 中文版（第六版）》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章 预备知识 1</summary>
          <blockquote>
          1.1 C++简介 2</br>
          <details>
          <summary>1.2 C++简史 2</summary>
              <blockquote>
              1.2.1 C语言 3</br>
              1.2.2 C语言编程原理 3</br>
              1.2.3 面向对象编程 3</br>
              1.2.4 C++和泛型编程 4</br>
              1.2.5 C++的起源 4</br>
              </blockquote>
          </details>
          <details>
          <summary>1.3 可移植性和标准 5</summary>
              <blockquote>
              1.3.1 C++的发展 6</br>
              1.3.2 本书遵循的C++标准 6</br>
              </blockquote>
          </details>
          <details>
          <summary>1.4 程序创建的技巧 7</summary>
              <blockquote>
              1.4.1 创建源代码文件 7</br>
              1.4.2 编译和链接 8</br>
              </blockquote>
          </details>
          1.5 总结 11</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章 开始学习C++ 13</summary>
          <blockquote>
          <details>
          <summary>2.1 进入C++ 14</summary>
              <blockquote>
              2.1.1 main( )函数 15</br>
              2.1.2 C++注释 17</br>
              2.1.3 C++预处理器和iostream文件 17</br>
              2.1.4 头文件名 18</br>
              2.1.5 名称空间 18</br>
              2.1.6 使用cout进行C++输出 19</br>
              2.1.7 C++源代码的格式化 21</br>
              </blockquote>
          </details>
          <details>
          <summary>2.2 C++语句 22</summary>
              <blockquote>
              2.2.1 声明语句和变量 22</br>
              2.2.2 赋值语句 23</br>
              2.2.3 cout的新花样 24</br>
              </blockquote>
          </details>
          <details>
          <summary>2.3 其他C++语句 24</summary>
              <blockquote>
              2.3.1 使用cin 25</br>
              2.3.2 使用cout进行拼接 25</br>
              2.3.3 类简介 26</br>
              </blockquote>
          </details>
          <details>
          <summary>2.4 函数 27</summary>
              <blockquote>
              2.4.1 使用有返回值的函数 27</br>
              2.4.2 函数变体 30</br>
              2.4.3 用户定义的函数 31</br>
              2.4.4 用户定义的有返回值的函数 33</br>
              2.4.5 在多函数程序中使用using编译指令 34</br>
              </blockquote>
          </details>
          2.5 总结 35</br>
          2.6 复习题 35</br>
          2.7 编程练习 36</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章 处理数据 37</summary>
          <blockquote>
          <details>
          <summary>3.1 简单变量 38</summary>
              <blockquote>
              3.1.1 变量名 38</br>
              3.1.2 整型 39</br>
              3.1.3 整型short、int、long和long long 39</br>
              3.1.4 无符号类型 43</br>
              3.1.5 选择整型类型 44</br>
              3.1.6 整型字面值 45</br>
              3.1.7 C++如何确定常量的类型 45</br>
              3.1.8 char类型：字符和小整数 46</br>
              3.1.9 bool类型 51</br>
              </blockquote>
          </details>
          3.2 const限定符 52</br>
          <details>
          <summary>3.3 浮点数 52</summary>
              <blockquote>
              3.3.1 书写浮点数 53</br>
              3.3.2 浮点类型 54</br>
              3.3.3 浮点常量 55</br>
              3.3.4 浮点数的优缺点 55</br>
              </blockquote>
          </details>
          <details>
          <summary>3.4 C++算术运算符 55</summary>
              <blockquote>
              3.4.1 运算符优先级和结合性 56</br>
              3.4.2 除法分支 57</br>
              3.4.3 求模运算符 57</br>
              3.4.4 类型转换 58</br>
              3.4.5 C++11中的auto声明 61</br>
              </blockquote>
          </details>
          3.5 总结 62</br>
          3.6 复习题 62</br>
          3.7 编程练习 63</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章 复合类型 65</summary>
          <blockquote>
          <details>
          <summary>4.1 数组 66</summary>
              <blockquote>
              4.1.1 程序说明 67</br>
              4.1.2 数组的初始化规则 68</br>
              4.1.3 C++11数组初始化方法 68</br>
              </blockquote>
          </details>
          <details>
          <summary>4.2 字符串 69</summary>
              <blockquote>
              4.2.1 拼接字符串常量 70</br>
              4.2.2 在数组中使用字符串 70</br>
              4.2.3 字符串输入 71</br>
              4.2.4 每次读取一行字符串输入 72</br>
              4.2.5 混合输入字符串和数字 74</br>
              </blockquote>
          </details>
          <details>
          <summary>4.3 string类简介 75</summary>
              <blockquote>
              4.3.1 C++11字符串初始化 76</br>
              4.3.2 赋值、拼接和附加 76</br>
              4.3.3 string类的其他操作 76</br>
              4.3.4 string类I/O 77</br>
              4.3.5 其他形式的字符串字面值 78</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4 结构简介 79</summary>
              <blockquote>
              4.4.1 在程序中使用结构 80</br>
              4.4.2 C++11结构初始化 81</br>
              4.4.3 结构可以将string类作为成员吗 81</br>
              4.4.4 其他结构属性 82</br>
              4.4.5 结构数组 82</br>
              4.4.6 结构中的位字段 83</br>
              </blockquote>
          </details>
          4.5 共用体 83</br>
          <details>
          <summary>4.6 枚举 84</summary>
              <blockquote>
              4.6.1 设置枚举量的值 85</br>
              4.6.2 枚举的取值范围 86</br>
              </blockquote>
          </details>
          <details>
          <summary>4.7 指针和自由存储空间 86</summary>
              <blockquote>
              4.7.1 声明和初始化指针 88</br>
              4.7.2 指针的危险 90</br>
              4.7.3 指针和数字 90</br>
              4.7.4 使用new来分配内存 90</br>
              4.7.5 使用delete释放内存 92</br>
              4.7.6 使用new来创建动态数组 92</br>
              </blockquote>
          </details>
          <details>
          <summary>4.8 指针、数组和指针算术 94</summary>
              <blockquote>
              4.8.1 程序说明 94</br>
              4.8.2 指针小结 96</br>
              4.8.3 指针和字符串 97</br>
              4.8.4 使用new创建动态结构 100</br>
              4.8.5 自动存储、静态存储和动态存储 101</br>
              </blockquote>
          </details>
          4.9 类型组合 103</br>
          <details>
          <summary>4.10 数组的替代品 104</summary>
              <blockquote>
              4.10.1 模板类vector 104</br>
              4.10.2 模板类array（C++11） 105</br>
              4.10.3 比较数组、vector对象和array对象 105</br>
              </blockquote>
          </details>
          4.11 总结 106</br>
          4.12 复习题 106</br>
          4.13 编程练习 107</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章 循环和关系表达式 109</summary>
          <blockquote>
          <details>
          <summary>5.1 for循环 110</summary>
              <blockquote>
              5.1.1 for循环的组成部分 110</br>
              5.1.2 回到for循环 114</br>
              5.1.3 修改步长 115</br>
              5.1.4 使用for循环访问字符串 116</br>
              5.1.5 递增运算符（++）和递减运算符（--） 116</br>
              5.1.6 副作用和顺序点 117</br>
              5.1.7 前缀格式和后缀格式 117</br>
              5.1.8 递增/递减运算符和指针 118</br>
              5.1.9 组合赋值运算符 119</br>
              5.1.10 复合语句（语句块） 119</br>
              5.1.11 其他语法技巧——逗号运算符 120</br>
              5.1.12 关系表达式 121</br>
              5.1.13 赋值、比较和可能犯的错误 122</br>
              5.1.14 C-风格字符串的比较 123</br>
              5.1.15 比较string类字符串 125</br>
              </blockquote>
          </details>
          <details>
          <summary>5.2 while循环 125</summary>
              <blockquote>
              5.2.1 for与while 127</br>
              </blockquote>
          </details>
          5.3.2 等待一段时间：编写延时循环 128</br>
          5.3 do while循环 129</br>
          5.4 基于范围的for循环（C++11） 131</br>
          <details>
          <summary>5.5 循环和文本输入 131</summary>
              <blockquote>
              5.5.1 使用原始的cin进行输入 131</br>
              5.5.2 使用cin.get(char)进行补救 132</br>
              5.5.3 使用哪一个cin.get( ) 132</br>
              5.5.4 文件尾条件 133</br>
              5.5.5 另一个cin.get( )版本 135</br>
              </blockquote>
          </details>
          <details>
          <summary>5.6 嵌套循环和二维数组 136</summary>
              <blockquote>
              5.6.1 初始化二维数组 138</br>
              5.6.2 使用二维数组 138</br>
              </blockquote>
          </details>
          5.7 总结 139</br>
          5.8 复习题 139</br>
          5.9 编程练习 140</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章 分支语句和逻辑运算符 143</summary>
          <blockquote>
          <details>
          <summary>6.1 if语句 144</summary>
              <blockquote>
              6.1.1 if else语句 145</br>
              6.1.2 格式化if else语句 146</br>
              6.1.3 if else if else结构 146</br>
              </blockquote>
          </details>
          <details>
          <summary>6.2 逻辑表达式 147</summary>
              <blockquote>
              6.2.1 逻辑OR运算符：|| 147</br>
              6.2.2 逻辑AND运算符：&& 148</br>
              6.2.3 用&&来设置取值范围 149</br>
              6.2.4 逻辑NOT运算符：! 150</br>
              6.2.5 逻辑运算符细节 151</br>
              6.2.6 其他表示方式 151</br>
              </blockquote>
          </details>
          6.3 字符函数库cctype 152</br>
          6.4 ?:运算符 153</br>
          <details>
          <summary>6.5 switch语句 154</summary>
              <blockquote>
              6.5.1 将枚举量用作标签 155</br>
              6.5.2 switch和if else 155</br>
              </blockquote>
          </details>
          6.6 break和continue语句 156</br>
          6.7 读取数字的循环 157</br>
          <details>
          <summary>6.8 简单文件输入/输出 159</summary>
              <blockquote>
              6.8.1 文本I/O和文本文件 159</br>
              6.8.2 写入到文本文件中 160</br>
              6.8.3 读取文本文件 162</br>
              </blockquote>
          </details>
          6.9 总结 164</br>
          6.10 复习题 165</br>
          6.11 编程练习 165</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章 函数——C++的编程模块 169</summary>
          <blockquote>
          <details>
          <summary>7.1 复习函数的基本知识 170</summary>
              <blockquote>
              7.1.1 定义函数 170</br>
              7.1.2 函数原型和函数调用 172</br>
              </blockquote>
          </details>
          <details>
          <summary>7.2 函数参数和按值传递 174</summary>
              <blockquote>
              7.2.1 多个参数 175</br>
              7.2.2 另外一个接受两个参数的函数 176</br>
              </blockquote>
          </details>
          <details>
          <summary>7.3 函数和数组 177</summary>
              <blockquote>
              7.3.1 函数如何使用指针来处理数组 178</br>
              7.3.2 将数组作为参数意味着什么 178</br>
              7.3.3 更多数组函数示例 180</br>
              7.3.4 使用数组区间的函数 182</br>
              7.3.5 指针和const 183</br>
              </blockquote>
          </details>
          7.4 函数和二维数组 185</br>
          <details>
          <summary>7.5 函数和C-风格字符串 186</summary>
              <blockquote>
              7.5.1 将C-风格字符串作为参数的函数 187</br>
              7.5.2 返回c-风格字符串的函数 187</br>
              </blockquote>
          </details>
          <details>
          <summary>7.6 函数和结构 188</summary>
              <blockquote>
              7.6.1 传递和返回结构 188</br>
              7.6.2 另一个处理结构的函数示例 189</br>
              7.6.3 传递结构的地址 192</br>
              </blockquote>
          </details>
          7.7 函数和string对象 192</br>
          7.8 函数与array对象 193</br>
          <details>
          <summary>7.9 递归 194</summary>
              <blockquote>
              7.9.1 包含一个递归调用的递归 194</br>
              7.9.2 包含多个递归调用的递归 195</br>
              </blockquote>
          </details>
          <details>
          <summary>7.10 函数指针 196</summary>
              <blockquote>
              7.10.1 函数指针的基础知识 196</br>
              7.10.2 函数指针示例 197</br>
              7.10.3 深入探讨函数指针 198</br>
              7.10.4 使用typedef进行简化 200</br>
              </blockquote>
          </details>
          7.11 总结 200</br>
          7.12 复习题 201</br>
          7.13 编程练习 202</br>
          </blockquote>
      </details>
      <details>
      <summary>第8章 函数探幽 205</summary>
          <blockquote>
          8.1 C++内联函数 206</br>
          <details>
          <summary>8.2 引用变量 208</summary>
              <blockquote>
              8.2.1 创建引用变量 208</br>
              8.2.2 将引用用作函数参数 209</br>
              8.2.3 引用的属性和特别之处 211</br>
              8.2.4 将引用用于结构 213</br>
              8.2.5 将引用用于类对象 217</br>
              8.2.6 对象、继承和引用 218</br>
              8.2.7 何时使用引用参数 219</br>
              </blockquote>
          </details>
          8.3 默认参数 220</br>
          <details>
          <summary>8.4 函数重载 221</summary>
              <blockquote>
              8.4.1 重载示例 223</br>
              8.4.2 何时使用函数重载 224</br>
              </blockquote>
          </details>
          <details>
          <summary>8.5 函数模板 224</summary>
              <blockquote>
              8.5.1 重载的模板 226</br>
              8.5.2 模板的局限性 226</br>
              8.5.3 显式具体化 226</br>
              8.5.4 实例化和具体化 227</br>
              8.5.5 编译器选择使用哪个函数版本 228</br>
              8.5.6 模板函数的发展 232</br>
              </blockquote>
          </details>
          8.6 总结 234</br>
          8.7 复习题 234</br>
          8.8 编程练习 235</br>
          </blockquote>
      </details>
      <details>
      <summary>第9章 内存模型和名称空间 237</summary>
          <blockquote>
          9.1 单独编译 238</br>
          <details>
          <summary>9.2 存储持续性、作用域和链接性 240</summary>
              <blockquote>
              9.2.1 作用域和链接 241</br>
              9.2.2 自动存储持续性 241</br>
              9.2.3 静态持续变量 243</br>
              9.2.4 静态持续性、外部链接性 245</br>
              9.2.5 静态持续性、内部链接性 247</br>
              9.2.6 静态存储持续性、无链接性 248</br>
              9.2.7 说明符和限定符 248</br>
              9.2.8 函数和链接性 250</br>
              9.2.9 语言链接性 250</br>
              9.2.10 存储方案和动态分配 251</br>
              </blockquote>
          </details>
          <details>
          <summary>9.3 名称空间 254</summary>
              <blockquote>
              9.3.1 传统的C++名称空间 254</br>
              9.3.2 新的名称空间特性 254</br>
              9.3.3 名称空间示例 259</br>
              9.3.4 名称空间及其前途 260</br>
              </blockquote>
          </details>
          9.4 总结 261</br>
          9.5 复习题 262</br>
          9.6 编程练习 262</br>
          </blockquote>
      </details>
      <details>
      <summary>第10章 对象和类 265</summary>
          <blockquote>
          10.1 过程性编程和面向对象编程 266</br>
          <details>
          <summary>10.2 抽象和类 267</summary>
              <blockquote>
              10.2.1 类型是什么 267</br>
              10.2.2 C++中的类 267</br>
              10.2.3 实现类成员函数 270</br>
              10.2.4 使用类 272</br>
              10.2.5 修改实现 273</br>
              10.2.6 小结 274</br>
              </blockquote>
          </details>
          <details>
          <summary>10.3 类的构造函数和析构函数 274</summary>
              <blockquote>
              10.3.1 声明和定义构造函数 275</br>
              10.3.2 使用构造函数 276</br>
              10.3.3 默认构造函数 276</br>
              10.3.4 析构函数 277</br>
              10.3.5 改进Stock类 278</br>
              10.3.6 构造函数和析构函数小结 281</br>
              </blockquote>
          </details>
          10.4 this指针 282</br>
          10.5 对象数组 285</br>
          <details>
          <summary>10.6 类作用域 286</summary>
              <blockquote>
              10.6.1 作用域为类的常量 286</br>
              10.6.2 作用域内枚举（C++11） 287</br>
              </blockquote>
          </details>
          10.7 抽象数据类型 288</br>
          10.8 总结 289</br>
          10.9 复习题 289</br>
          10.11 编程练习 290</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章 使用类 293</summary>
          <blockquote>
          11.1 运算符重载 294</br>
          <details>
          <summary>11.2 计算时间：一个运算符重载示例 295</summary>
              <blockquote>
              11.2.1 添加加法运算符 296</br>
              11.2.2 重载限制 297</br>
              11.2.3 其他重载运算符 298</br>
              </blockquote>
          </details>
          <details>
          <summary>11.3 友元 298</summary>
              <blockquote>
              11.3.1 创建友元 300</br>
              11.3.2 常用的友元：重载<<运算符 300</br>
              </blockquote>
          </details>
          11.4 重载运算符：作为成员函数还是非成员函数 304</br>
          <details>
          <summary>11.5 再谈重载：一个矢量类 304</summary>
              <blockquote>
              11.5.1 使用状态成员 307</br>
              11.5.2 为Vector类重载算术运算符 308</br>
              11.5.3 对实现的说明 309</br>
              11.5.4 使用Vector类来模拟随机漫步 310</br>
              </blockquote>
          </details>
          <details>
          <summary>11.6 类的自动转换和强制类型转换 311</summary>
              <blockquote>
              11.6.1 转换函数 314</br>
              11.6.2 转换函数和友元函数 317</br>
              </blockquote>
          </details>
          11.7 总结 319</br>
          11.8 复习题 320</br>
          11.9 编程练习 320</br>
          </blockquote>
      </details>
      <details>
      <summary>第12章 类和动态内存分配 323</summary>
          <blockquote>
          <details>
          <summary>12.1 动态内存和类 324</summary>
              <blockquote>
              12.1.1 复习示例和静态类成员 324</br>
              12.1.2 特殊成员函数 328</br>
              12.1.3 回到Stringbad：复制构造函数的哪里出了问题 330</br>
              12.1.4 Stringbad的其他问题：赋值运算符 333</br>
              </blockquote>
          </details>
          <details>
          <summary>12.2 改进后的新String类 334</summary>
              <blockquote>
              12.2.1 修订后的默认构造函数 335</br>
              12.2.2 比较成员函数 335</br>
              12.2.3 使用中括号表示法访问字符 336</br>
              12.2.4 静态类成员函数 337</br>
              12.2.5 进一步重载赋值运算符 338</br>
              </blockquote>
          </details>
          <details>
          <summary>12.3 在构造函数中使用new时应注意的事项 339</summary>
              <blockquote>
              12.3.1 应该和不应该 339</br>
              12.3.2 包含类成员的类的逐成员复制 340</br>
              </blockquote>
          </details>
          <details>
          <summary>12.4 有关返回对象的说明 340</summary>
              <blockquote>
              12.4.1 返回指向const对象的引用 340</br>
              12.4.2 返回指向非const对象的引用 341</br>
              12.4.3 返回对象 341</br>
              12.4.4 返回const对象 341</br>
              </blockquote>
          </details>
          <details>
          <summary>12.5 使用指向对象的指针 342</summary>
              <blockquote>
              12.5.1 再谈new和delete 343</br>
              12.5.2 指针和对象小结 344</br>
              12.5.3 再谈定位new运算符 345</br>
              </blockquote>
          </details>
          <details>
          <summary>12.6 复习各种技术 346</summary>
              <blockquote>
              12.6.1 重载<<运算符 346</br>
              12.6.2 转换函数 347</br>
              12.6.3 其构造函数使用new的类 347</br>
              </blockquote>
          </details>
          <details>
          <summary>12.7 队列模拟 347</summary>
              <blockquote>
              12.7.1 队列类 348</br>
              12.7.2 Customer类 354</br>
              12.7.3 ATM模拟 355</br>
              </blockquote>
          </details>
          12.8 总结 356</br>
          12.9 复习题 357</br>
          12.10 编程练习 357</br>
          </blockquote>
      </details>
      <details>
      <summary>第13章 类继承 359</summary>
          <blockquote>
          <details>
          <summary>13.1 一个简单的基类 360</summary>
              <blockquote>
              13.1.1 派生一个类 361</br>
              13.1.2 构造函数：访问权限的考虑 362</br>
              13.1.3 使用派生类 364</br>
              13.1.4 派生类和基类之间的特殊关系 364</br>
              </blockquote>
          </details>
          13.2 继承：is-a关系 366</br>
          <details>
          <summary>13.3 多态公有继承 367</summary>
              <blockquote>
              13.3.1 开发Brass类和BrassPlus类 367</br>
              </blockquote>
          </details>
          <details>
          <summary>13.4 静态联编和动态联编 371</summary>
              <blockquote>
              13.4.1 指针和引用类型的兼容性 371</br>
              13.4.2 虚成员函数和动态联编 372</br>
              13.4.3 有关虚函数注意事项 373</br>
              </blockquote>
          </details>
          13.5 访问控制：protected 375</br>
          <details>
          <summary>13.6 抽象基类 375</summary>
              <blockquote>
              13.6.1 应用ABC概念 377</br>
              13.6.2 ABC理念 378</br>
              </blockquote>
          </details>
          <details>
          <summary>13.7 继承和动态内存分配 378</summary>
              <blockquote>
              13.7.1 第一种情况：派生类不使用new 378</br>
              13.7.2 第二种情况：派生类使用new 379</br>
              13.7.3 使用动态内存分配和友元的继承示例 380</br>
              </blockquote>
          </details>
          <details>
          <summary>13.8 类设计回顾 381</summary>
              <blockquote>
              13.8.1 编译器生成的成员函数 381</br>
              13.8.2 其他的类方法 382</br>
              13.8.3 公有继承的考虑因素 384</br>
              13.8.4 类函数小结 386</br>
              </blockquote>
          </details>
          13.9 总结 387</br>
          13.10 复习题 387</br>
          13.11 编程练习 388</br>
          </blockquote>
      </details>
      <details>
      <summary>第14章 C++中的代码重用 391</summary>
          <blockquote>
          <details>
          <summary>14.1 包含对象成员的类 392</summary>
              <blockquote>
              14.1.1 valarray类简介 392</br>
              14.1.2 Student类的设计 393</br>
              14.1.3 Student类示例 394</br>
              </blockquote>
          </details>
          <details>
          <summary>14.2 私有继承 396</summary>
              <blockquote>
              14.2.1 Student类示例（新版本） 396</br>
              14.2.2 使用包含还是私有继承 398</br>
              14.2.3 保护继承 399</br>
              14.2.4 使用using重新定义访问权限 399</br>
              </blockquote>
          </details>
          <details>
          <summary>14.3 多重继承 400</summary>
              <blockquote>
              14.3.1 有多少Worker 401</br>
              14.3.2 哪个方法 404</br>
              14.3.3 MI小结 406</br>
              </blockquote>
          </details>
          <details>
          <summary>14.4 类模板 407</summary>
              <blockquote>
              14.4.1 定义类模板 407</br>
              14.4.2 使用模板类 408</br>
              14.4.3 深入探讨模板类 409</br>
              14.4.4 数组模板示例和非类型参数 411</br>
              14.4.5 模板多功能性 411</br>
              14.4.6 模板的具体化 413</br>
              14.4.7 成员模板 414</br>
              14.4.8 将模板用作参数 415</br>
              14.4.9 模板类和友元 416</br>
              14.4.10 模板别名（C++11） 419</br>
              </blockquote>
          </details>
          14.5 总结 419</br>
          14.6 复习题 421</br>
          14.7 编程练习 421</br>
          </blockquote>
      </details>
      <details>
      <summary>第15章 友元、异常和其他 425</summary>
          <blockquote>
          <details>
          <summary>15.1 友元 426</summary>
              <blockquote>
              15.1.1 友元类 426</br>
              15.1.2 友元成员函数 427</br>
              15.1.3 其他友元关系 429</br>
              </blockquote>
          </details>
          <details>
          <summary>15.2 嵌套类 429</summary>
              <blockquote>
              15.2.1 嵌套类和访问权限 430</br>
              15.2.2 模板中的嵌套 431</br>
              </blockquote>
          </details>
          <details>
          <summary>15.3 异常 432</summary>
              <blockquote>
              15.3.1 调用abort( ) 432</br>
              15.3.2 返回错误码 432</br>
              15.3.3 异常机制 433</br>
              <details>
              <summary>15.3.4 将对象用作异常类型 435</summary>
                  <blockquote>
                  15.3.4 异常规范和C++11 436</br>
                  </blockquote>
              </details>
              15.3.5 栈解退 436</br>
              15.3.6 其他异常特性 439</br>
              15.3.7 exception类 440</br>
              15.3.8 异常、类和继承 442</br>
              15.3.9 异常何时会迷失方向 442</br>
              15.3.10 有关异常的注意事项 444</br>
              </blockquote>
          </details>
          <details>
          <summary>15.4 RTTI 445</summary>
              <blockquote>
              15.4.1 RTTI的用途 445</br>
              15.4.2 RTTI的工作原理 445</br>
              </blockquote>
          </details>
          15.5 类型转换运算符 449</br>
          15.6 总结 451</br>
          15.7 复习题 451</br>
          15.8 编程练习 452</br>
          </blockquote>
      </details>
      <details>
      <summary>第16章 string类和标准模板库 453</summary>
          <blockquote>
          <details>
          <summary>16.1 string类 454</summary>
              <blockquote>
              16.1.1 构造字符串 454</br>
              16.1.2 string类输入 457</br>
              16.1.3 使用字符串 458</br>
              16.1.4 string还提供了哪些功能 460</br>
              16.1.5 字符串种类 461</br>
              </blockquote>
          </details>
          <details>
          <summary>16.2 智能指针模板类 461</summary>
              <blockquote>
              16.2.1 使用智能指针 462</br>
              16.2.2 有关智能指针的注意事项 464</br>
              16.2.3 unique_ptr为何优于auto_ptr 465</br>
              16.2.4 选择智能指针 466</br>
              </blockquote>
          </details>
          <details>
          <summary>16.3 标准模板库 466</summary>
              <blockquote>
              16.3.1 模板类vector 467</br>
              16.3.2 可对矢量执行的操作 467</br>
              16.3.3 对矢量可执行的其他操作 469</br>
              16.3.4 基于范围的for循环（C++11） 471</br>
              </blockquote>
          </details>
          <details>
          <summary>16.4 泛型编程 471</summary>
              <blockquote>
              16.4.1 为何使用迭代器 472</br>
              16.4.2 迭代器类型 474</br>
              16.4.3 迭代器层次结构 475</br>
              16.4.4 概念、改进和模型 476</br>
              16.4.5 容器种类 480</br>
              16.4.4 关联容器 485</br>
              16.4.5 无序关联容器（C++11） 488</br>
              </blockquote>
          </details>
          <details>
          <summary>16.5 函数对象 488</summary>
              <blockquote>
              16.5.1 函数符概念 489</br>
              16.5.2 预定义的函数符 490</br>
              16.5.3 自适应函数符和函数适配器 491</br>
              </blockquote>
          </details>
          <details>
          <summary>16.6 算法 493</summary>
              <blockquote>
              16.6.1 算法组 493</br>
              16.6.2 算法的通用特征 493</br>
              16.6.3 STL和string类 494</br>
              16.6.4 函数和容器方法 494</br>
              16.6.5 使用STL 495</br>
              </blockquote>
          </details>
          <details>
          <summary>16.7 其他库 496</summary>
              <blockquote>
              16.7.1 vector、valarray和array 497</br>
              16.7.2 模板initializer_list（C++11） 500</br>
              16.7.3 使用initializer_list 500</br>
              </blockquote>
          </details>
          16.8 总结 501</br>
          16.9 复习题 502</br>
          16.10 编程练习 503</br>
          </blockquote>
      </details>
      <details>
      <summary>第17章 输入、输出和文件 505</summary>
          <blockquote>
          <details>
          <summary>17.1 C++输入和输出概述 506</summary>
              <blockquote>
              17.1.1 流和缓冲区 506</br>
              17.1.2 流、缓冲区和iostream文件 508</br>
              17.1.3 重定向 510</br>
              </blockquote>
          </details>
          <details>
          <summary>17.2 使用cout进行输出 510</summary>
              <blockquote>
              17.2.1 重载的<<运算符 511</br>
              17.2.2 其他ostream方法 512</br>
              17.2.3 刷新输出缓冲区 514</br>
              17.2.4 用cout进行格式化 515</br>
              </blockquote>
          </details>
          <details>
          <summary>17.3 使用cin进行输入 522</summary>
              <blockquote>
              17.3.1 cin>>如何检查输入 523</br>
              17.3.2 流状态 524</br>
              17.3.3 其他istream类方法 527</br>
              17.3.4 其他istream方法 530</br>
              </blockquote>
          </details>
          <details>
          <summary>17.4 文件输入和输出 532</summary>
              <blockquote>
              17.4.1 简单的文件I/O 532</br>
              17.4.2 流状态检查和is_open( ) 534</br>
              <details>
              <summary>17.4.3 打开多个文件 534</summary>
                  <blockquote>
                  17.4.3 命令行处理技术 535</br>
                  </blockquote>
              </details>
              17.4.5 文件模式 536</br>
              17.4.6 随机存取 540</br>
              </blockquote>
          </details>
          17.5 内核格式化 543</br>
          17.6 总结 544</br>
          17.7 复习题 545</br>
          17.8 编程练习 546</br>
          </blockquote>
      </details>
      <details>
      <summary>第18章 探讨C++新标准 549</summary>
          <blockquote>
          <details>
          <summary>18.1 复习前面介绍过的C++11功能 550</summary>
              <blockquote>
              18.1.1 新类型 550</br>
              </blockquote>
          </details>
          18.8.2 统一的初始化 550</br>
          18.1.3 声明 551</br>
          18.1.4 智能指针 552</br>
          18.1.5 异常规范方面的修改 552</br>
          18.1.6 作用域内枚举 553</br>
          18.1.7 对类的修改 553</br>
          18.1.8 模板和STL方面的修改 554</br>
          18.1.9 右值引用 555</br>
          <details>
          <summary>18.2 移动语义和右值引用 555</summary>
              <blockquote>
              18.2.1 为何需要移动语义 555</br>
              18.2.2 一个移动示例 556</br>
              18.2.3 移动构造函数解析 557</br>
              18.2.4 赋值 558</br>
              18.2.5 强制移动 558</br>
              </blockquote>
          </details>
          <details>
          <summary>18.3 新的类功能 559</summary>
              <blockquote>
              18.3.1 特殊的成员函数 559</br>
              18.3.2 默认的方法和禁用的方法 559</br>
              18.3.3 委托构造函数 560</br>
              18.3.4 继承构造函数 560</br>
              18.3.5 管理虚方法：override和final 561</br>
              </blockquote>
          </details>
          <details>
          <summary>18.4 Lambda函数 561</summary>
              <blockquote>
              18.4.1 比较函数指针、函数符和Lambda函数 562</br>
              18.4.2 为何使用lambda 563</br>
              </blockquote>
          </details>
          <details>
          <summary>18.5 包装器 564</summary>
              <blockquote>
              18.5.1 包装器function及模板的低效性 565</br>
              18.5.2 修复问题 566</br>
              18.5.3 其他方式 566</br>
              </blockquote>
          </details>
          <details>
          <summary>18.6 可变参数模板 567</summary>
              <blockquote>
              18.6.1 模板和函数参数包 567</br>
              18.6.2 展开参数包 568</br>
              18.6.3 在可变参数模板函数中使用递归 568</br>
              </blockquote>
          </details>
          <details>
          <summary>18.7 C++11新增的其他功能 570</summary>
              <blockquote>
              18.7.1 并行编程 570</br>
              18.7.2 新增的库 570</br>
              18.7.3 低级编程 570</br>
              18.7.4 杂项 571</br>
              </blockquote>
          </details>
          <details>
          <summary>18.8 语言变化 571</summary>
              <blockquote>
              18.8.1 Boost项目 571</br>
              18.8.2 TR1 572</br>
              18.8.3 使用Boost 572</br>
              </blockquote>
          </details>
          18.9 接下来的任务 572</br>
          18.10 总结 573</br>
          18.11 复习题 573</br>
          18.12 编程练习 574</br>
          </blockquote>
      </details>
      <details>
          <summary>附录A 计数系统 575</summary>
              <blockquote>
              A.1 十进制数 576</br>
              A.2 八进制整数 576</br>
              A.3 十六进制数 576</br>
              A.4 二进制数 577</br>
              A.5 二进制和十六进制 577</br>
              </blockquote>
          </details>
          <details>
          <summary>附录B C++保留字 579</summary>
              <blockquote>
              B.1 C++关键字 580</br>
              B.2 替代标记 580</br>
              B.3 C++库保留名称 580</br>
              B.4 有特殊含义的标识符 581</br>
              </blockquote>
          </details>
          <details>
          <summary>附录C ASCII字符集 583</summary>
              <blockquote>
              </blockquote>
          </details>
          <details>
          <summary>附录D 运算符优先级 589</summary>
              <blockquote>
              </blockquote>
          </details>
          <details>
          <summary>附录E 其他运算符 593</summary>
              <blockquote>
              <details>
              <summary>E.1 按位运算符 594</summary>
                  <blockquote>
                  E.1.1 移位运算符 594</br>
                  E.1.2 逻辑按位运算符 595</br>
                  E.1.3 按位运算符的替代表示 597</br>
                  E.1.4 几种常用的按位运算符技术 598</br>
                  </blockquote>
              </details>
              E.2 成员解除引用运算符 599</br>
              E.3 alignof（C++11） 600</br>
              E.4 noexcept（C++11） 601</br>
              </blockquote>
          </details>
          <details>
          <summary>附录F 模板类string 603</summary>
              <blockquote>
              F.1 13种类型和一个常量 604</br>
              <details>
              <summary>F.2 数据信息、构造函数及其他 605</summary>
                  <blockquote>
                  F.2.1 默认构造函数 606</br>
                  F.2.2 使用C-风格字符串的构造函数 607</br>
                  F.2.3 使用部分C-风格字符串的构造函数 607</br>
                  F.2.4 使用左值引用的构造函数 607</br>
                  F.2.5 使用右值引用的构造函数（C++11） 608</br>
                  F.2.6 使用一个字符的n个副本的构造函数 609</br>
                  F.2.7 使用区间的构造函数 609</br>
                  F.2.8 使用初始化列表的构造函数（C++11） 609</br>
                  F.2.9 内存杂记 610</br>
                  </blockquote>
              </details>
              F.3 字符串存取 610</br>
              F.4 基本赋值 611</br>
              <details>
              <summary>F.5 字符串搜索 611</summary>
                  <blockquote>
                  F.5.1 find( )系列 611</br>
                  F.5.2 rfind( )系列 612</br>
                  F.5.3 find_first_of( )系列 612</br>
                  F.5.4 find_last_of( )系列 612</br>
                  F.5.5 find_first_not_of( )系列 612</br>
                  F.5.6 find_last_not_of( )系列 613</br>
                  </blockquote>
              </details>
              F.6 比较方法和函数 613</br>
              <details>
              <summary>F.7 字符串修改方法 614</summary>
                  <blockquote>
                  F.7.1 用于追加和相加的方法 614</br>
                  F.7.2 其他赋值方法 614</br>
                  F.7.3 插入方法 614</br>
                  F.7.4 清除方法 615</br>
                  F.7.5 替换方法 615</br>
                  F.7.6 其他修改方法：copy( )和swap( ) 615</br>
                  </blockquote>
              </details>
              F.8 输出和输入 616</br>
              </blockquote>
          </details>
          <details>
          <summary>附录G 标准模板库方法和函数 617</summary>
              <blockquote>
              <details>
              <summary>G.1 STL和C++11 618</summary>
                  <blockquote>
                  G.1.1 新增的容器 618</br>
                  G.1.2 对C++98容器所做的修改 618</br>
                  </blockquote>
              </details>
              G.2 大部分容器都有的成员 619</br>
              G.3 序列容器的其他成员 621</br>
              <details>
              <summary>G.4 set和map的其他操作 623</summary>
                  <blockquote>
                  G.4 无序关联容器（C++11） 625</br>
                  </blockquote>
              </details>
              <details>
              <summary>G.5 STL函数 626</summary>
                  <blockquote>
                  G.5.1 非修改式序列操作 626</br>
                  G.5.2 修改式序列操作 629</br>
                  G.5.3 排序和相关操作 635</br>
                  G.5.4 数值运算 642</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>附录H 精选读物和网上资源 645</summary>
              <blockquote>
              H.1 精选读物 646</br>
              H.2 网上资源 647</br>
              </blockquote>
          </details>
          <details>
          <summary>附录I 转换为ISO标准C++ 649</summary>
              <blockquote>
              <details>
              <summary>I.1 使用一些预处理器编译指令的替代品 650</summary>
                  <blockquote>
                  I.1.1 使用const而不是#define来定义常量 650</br>
                  I.1.2 使用inline而不是# define来定义小型函数 651</br>
                  </blockquote>
              </details>
              I.2 使用函数原型 651</br>
              I.3 使用类型转换 652</br>
              I.4 熟悉C++特性 652</br>
              I.5 使用新的头文件 652</br>
              I.6 使用名称空间 652</br>
              I.7 使用智能指针 653</br>
              I.8 使用string类 653</br>
              I.9 使用STL 654</br>
              </blockquote>
          </details>
          <details>
          <summary>附录J 复习题答案 655</summary>
              <blockquote>
              第2章复习题答案 656</br>
              第3章复习题答案 656</br>
              第4章复习题答案 657</br>
              第5章复习题答案 658</br>
              第6章复习题答案 659</br>
              第7章复习题答案 660</br>
              第8章复习题答案 661</br>
              第9章复习题答案 662</br>
              第10章复习题答案 662</br>
              第11章复习题答案 663</br>
              第12章复习题答案 664</br>
              第13章复习题答案 665</br>
              第14章复习题答案 665</br>
              第15章复习题答案 666</br>
              第16章复习题答案 667</br>
              第17章复习题答案 667</br>
              第18章复习题答案 668</br>
              </blockquote>
          </details>
      </blockquote>
  </details></li>
<li>《C++ Primer》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章 开始 1</summary>
          <blockquote>
          <details>
          <summary>1.1 编写一个简单的C++程序 2</summary>
              <blockquote>
              1.1.1 编译、运行程序 3</br>
              </blockquote>
          </details>
          1.2 初识输入输出 5</br>
          1.3 注释简介 8</br>
          <details>
          <summary>1.4 控制流 10</summary>
              <blockquote>
              1.4.1 while语句 10</br>
              1.4.2 for语句 11</br>
              1.4.3 读取数量不定的输入数据 13</br>
              1.4.4 if语句 15</br>
              </blockquote>
          </details>
          <details>
          <summary>1.5 类简介 17</summary>
              <blockquote>
              1.5.1 Sales_item类 17</br>
              1.5.2 初识成员函数 20</br>
              </blockquote>
          </details>
          1.6 书店程序 21</br>
          小结 23</br>
          术语表 23</br>
          </blockquote>
      </details>
      <details>
      <summary>第Ⅰ部分 C++基础 27</summary>
          <blockquote>
          <details>
          <summary>第2章 变量和基本类型 29</summary>
              <blockquote>
              <details>
              <summary>2.1 基本内置类型 30</summary>
                  <blockquote>
                  2.1.1 算术类型 30</br>
                  2.1.2 类型转换 32</br>
                  2.1.3 字面值常量 35</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.2 变量 38</summary>
                  <blockquote>
                  2.2.1 变量定义 38</br>
                  2.2.2 变量声明和定义的关系 41</br>
                  2.2.3 标识符 42</br>
                  2.2.4 名字的作用域 43</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.3 复合类型 45</summary>
                  <blockquote>
                  2.3.1 引用 45</br>
                  2.3.2 指针 47</br>
                  2.3.3 理解复合类型的声明 51</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.4 const限定符 53</summary>
                  <blockquote>
                  2.4.1 const的引用 54</br>
                  2.4.2 指针和const 56</br>
                  2.4.3 顶层const 57</br>
                  2.4.4 constexpr和常量表达式 58</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.5 处理类型 60</summary>
                  <blockquote>
                  2.5.1 类型别名 60</br>
                  2.5.2 auto类型说明符 61</br>
                  2.5.3 decltype类型指示符 62</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.6 自定义数据结构 64</summary>
                  <blockquote>
                  2.6.1 定义Sales_data类型 64</br>
                  2.6.2 使用Sales_data类 66</br>
                  2.6.3 编写自己的头文件 67</br>
                  </blockquote>
              </details>
              小结 69</br>
              术语表 69</br>
              </blockquote>
          </details>
          <details>
          <summary>第3章 字符串、向量和数组 73</summary>
              <blockquote>
              3.1 命名空间的using声明 74</br>
              <details>
              <summary>3.2 标准库类型string 75</summary>
                  <blockquote>
                  3.2.1 定义和初始化string对象 76</br>
                  3.2.2 string对象上的操作 77</br>
                  3.2.3 处理string对象中的字符 81</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.3 标准库类型vector 86</summary>
                  <blockquote>
                  3.3.1 定义和初始化vector对象 87</br>
                  3.3.2 向vector对象中添加元素 90</br>
                  3.3.3 其他vector操作 91</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.4 迭代器介绍 95</summary>
                  <blockquote>
                  3.4.1 使用迭代器 95</br>
                  3.4.2 迭代器运算 99</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.5 数组 101</summary>
                  <blockquote>
                  3.5.1 定义和初始化内置数组 101</br>
                  3.5.2 访问数组元素 103</br>
                  3.5.3 指针和数组 105</br>
                  3.5.4 C风格字符串 109</br>
                  3.5.5 与旧代码的接口 111</br>
                  </blockquote>
              </details>
              3.6 多维数组 112</br>
              小结 117</br>
              术语表 117</br>
              </blockquote>
          </details>
          <details>
          <summary>第4章 表达式 119</summary>
              <blockquote>
              <details>
              <summary>4.1 基础 120</summary>
                  <blockquote>
                  4.1.1 基本概念 120</br>
                  4.1.2 优先级与结合律 121</br>
                  4.1.3 求值顺序 123</br>
                  </blockquote>
              </details>
              4.2 算术运算符 124</br>
              4.3 逻辑和关系运算符 126</br>
              4.4 赋值运算符 129</br>
              4.5 递增和递减运算符 131</br>
              4.6 成员访问运算符 133</br>
              4.7 条件运算符 134</br>
              4.8 位运算符 135</br>
              4.9 sizeof运算符 139</br>
              4.10 逗号运算符 140</br>
              <details>
              <summary>4.11 类型转换 141</summary>
                  <blockquote>
                  4.11.1 算术转换 142</br>
                  4.11.2 其他隐式类型转换 143</br>
                  4.11.3 显式转换 144</br>
                  </blockquote>
              </details>
              4.12 运算符优先级表 147</br>
              小结 149</br>
              术语表 149</br>
              </blockquote>
          </details>
          <details>
          <summary>第5章 语句 153</summary>
              <blockquote>
              5.1 简单语句 154</br>
              5.2 语句作用域 155</br>
              <details>
              <summary>5.3 条件语句 156</summary>
                  <blockquote>
                  5.3.1 if语句 156</br>
                  5.3.2 switch语句 159</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.4 迭代语句 165</summary>
                  <blockquote>
                  5.4.1 while语句 165</br>
                  5.4.2 传统的for语句 166</br>
                  5.4.3 范围for语句 168</br>
                  5.4.4 do while语句 169</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.5 跳转语句 170</summary>
                  <blockquote>
                  5.5.1 break语句 170</br>
                  5.5.2 continue语句 171</br>
                  5.5.3 goto语句 172</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.6 TRY语句块和异常处理 172</summary>
                  <blockquote>
                  5.6.1 throw表达式 173</br>
                  5.6.2 try语句块 174</br>
                  5.6.3 标准异常 176</br>
                  </blockquote>
              </details>
              小结 178</br>
              术语表 178</br>
              </blockquote>
          </details>
          <details>
          <summary>第6章 函数 181</summary>
              <blockquote>
              <details>
              <summary>6.1 函数基础 182</summary>
                  <blockquote>
                  6.1.1 局部对象 184</br>
                  6.1.2 函数声明 186</br>
                  6.1.3 分离式编译 186</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.2 参数传递 187</summary>
                  <blockquote>
                  6.2.1 传值参数 187</br>
                  6.2.2 传引用参数 188</br>
                  6.2.3 const形参和实参 190</br>
                  6.2.4 数组形参 193</br>
                  6.2.5 main：处理命令行选项 196</br>
                  6.2.6 含有可变形参的函数 197</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.3 返回类型和return语句 199</summary>
                  <blockquote>
                  6.3.1 无返回值函数 200</br>
                  6.3.2 有返回值函数 200</br>
                  6.3.3 返回数组指针 205</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.4 函数重载 206</summary>
                  <blockquote>
                  6.4.1 重载与作用域 210</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.5 特殊用途语言特性 211</summary>
                  <blockquote>
                  6.5.1 默认实参 211</br>
                  6.5.2 内联函数和constexpr函数 213</br>
                  6.5.3 调试帮助 215</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.6 函数匹配 217</summary>
                  <blockquote>
                  6.6.1 实参类型转换 219</br>
                  </blockquote>
              </details>
              6.7 函数指针 221</br>
              小结 225</br>
              术语表 225</br>
              </blockquote>
          </details>
          <details>
          <summary>第7章 类 227</summary>
              <blockquote>
              <details>
              <summary>7.1 定义抽象数据类型 228</summary>
                  <blockquote>
                  7.1.1 设计Sales_data类 228</br>
                  7.1.2 定义改进的Sales_data类 230</br>
                  7.1.3 定义类相关的非成员函数 234</br>
                  7.1.4 构造函数 235</br>
                  7.1.5 拷贝、赋值和析构 239</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.2 访问控制与封装 240</summary>
                  <blockquote>
                  7.2.1 友元 241</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.3 类的其他特性 243</summary>
                  <blockquote>
                  7.3.1 类成员再探 243</br>
                  7.3.2 返回*this的成员函数 246</br>
                  7.3.3 类类型 249</br>
                  7.3.4 友元再探 250</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.4 类的作用域 253</summary>
                  <blockquote>
                  7.4.1 名字查找与类的作用域 254</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.5 构造函数再探 257</summary>
                  <blockquote>
                  7.5.1 构造函数初始值列表 258</br>
                  7.5.2 委托构造函数 261</br>
                  7.5.3 默认构造函数的作用 262</br>
                  7.5.4 隐式的类类型转换 263</br>
                  7.5.5 聚合类 266</br>
                  7.5.6 字面值常量类 267</br>
                  </blockquote>
              </details>
              7.6 类的静态成员 268</br>
              小结 273</br>
              术语表 273</br>
              </blockquote>
              </details>
          </blockquote>
      </details>
      <details>
      <summary>第Ⅱ部 C++标准库 275</summary>
          <blockquote>
          <details>
          <summary>第8章 IO库 277</summary>
              <blockquote>
              <details>
              <summary>8.1 IO类 278</summary>
                  <blockquote>
                  8.1.1 IO对象无拷贝或赋值 279</br>
                  8.1.2 条件状态 279</br>
                  8.1.3 管理输出缓冲 281</br>
                  </blockquote>
              </details>
              <details>
              <summary>8.2 文件输入输出 283</summary>
                  <blockquote>
                  8.2.1 使用文件流对象 284</br>
                  8.2.2 文件模式 286</br>
                  </blockquote>
              </details>
              <details>
              <summary>8.3 string流 287</summary>
                  <blockquote>
                  8.3.1 使用istringstream 287</br>
                  8.3.2 使用ostringstream 289</br>
                  </blockquote>
              </details>
              小结 290</br>
              术语表 290</br>
              </blockquote>
          </details>
          <details>
          <summary>第9章 顺序容器 291</summary>
              <blockquote>
              9.1 顺序容器概述 292</br>
              <details>
              <summary>9.2 容器库概览 294</summary>
                  <blockquote>
                  9.2.1 迭代器 296</br>
                  9.2.2 容器类型成员 297</br>
                  9.2.3 begin和end成员 298</br>
                  9.2.4 容器定义和初始化 299</br>
                  9.2.5 赋值和swap 302</br>
                  9.2.6 容器大小操作 304</br>
                  9.2.7 关系运算符 304</br>
                  </blockquote>
              </details>
              <details>
              <summary>9.3 顺序容器操作 305</summary>
                  <blockquote>
                  9.3.1 向顺序容器添加元素 305</br>
                  9.3.2 访问元素 309</br>
                  9.3.3 删除元素 311</br>
                  9.3.4 特殊的forward_list操作 312</br>
                  9.3.5 改变容器大小 314</br>
                  9.3.6 容器操作可能使迭代器失效 315</br>
                  </blockquote>
              </details>
              9.4 vector对象是如何增长的 317</br>
              <details>
              <summary>9.5 额外的string操作 320</summary>
                  <blockquote>
                  9.5.1 构造string的其他方法 321</br>
                  9.5.2 改变string的其他方法 322</br>
                  9.5.3 string搜索操作 325</br>
                  9.5.4 compare函数 327</br>
                  9.5.5 数值转换 327</br>
                  </blockquote>
              </details>
              9.6 容器适配器 329</br>
              小结 332</br>
              术语表 332</br>
              </blockquote>
          </details>
          <details>
          <summary>第10章 泛型算法 335</summary>
              <blockquote>
              10.1 概述 336</br>
              <details>
              <summary>10.2 初识泛型算法 338</summary>
                  <blockquote>
                  10.2.1 只读算法 338</br>
                  10.2.2 写容器元素的算法 339</br>
                  10.2.3 重排容器元素的算法 342</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.3 定制操作 344</summary>
                  <blockquote>
                  10.3.1 向算法传递函数 344</br>
                  10.3.2 lambda表达式 345</br>
                  10.3.3 lambda捕获和返回 349</br>
                  10.3.4 参数绑定 354</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.4 再探迭代器 357</summary>
                  <blockquote>
                  10.4.1 插入迭代器 358</br>
                  10.4.2 iostream迭代器 359</br>
                  10.4.3 反向迭代器 363</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.5 泛型算法结构 365</summary>
                  <blockquote>
                  10.5.1 5类迭代器 365</br>
                  10.5.2 算法形参模式 367</br>
                  10.5.3 算法命名规范 368</br>
                  </blockquote>
              </details>
              10.6 特定容器算法 369</br>
              小结 371</br>
              术语表 371</br>
              </blockquote>
          </details>
          <details>
          <summary>第11章 关联容器 373</summary>
              <blockquote>
              11.1 使用关联容器 374</br>
              <details>
              <summary>11.2 关联容器概述 376</summary>
                  <blockquote>
                  11.2.1 定义关联容器 376</br>
                  11.2.2 关键字类型的要求 378</br>
                  11.2.3 pair类型 379</br>
                  </blockquote>
              </details>
              <details>
              <summary>11.3 关联容器操作 381</summary>
                  <blockquote>
                  11.3.1 关联容器迭代器 382</br>
                  11.3.2 添加元素 383</br>
                  11.3.3 删除元素 386</br>
                  11.3.4 map的下标操作 387</br>
                  11.3.5 访问元素 388</br>
                  11.3.6 一个单词转换的map 391</br>
                  </blockquote>
              </details>
              11.4 无序容器 394</br>
              小结 397</br>
              术语表 397</br>
              </blockquote>
          </details>
          <details>
          <summary>第12章 动态内存 399</summary>
              <blockquote>
              <details>
              <summary>12.1 动态内存与智能指针 400</summary>
                  <blockquote>
                  12.1.1 shared_ptr类 400</br>
                  12.1.2 直接管理内存 407</br>
                  12.1.3 shared_ptr和new结合使用 412</br>
                  12.1.4 智能指针和异常 415</br>
                  12.1.5 unique_ptr 417</br>
                  12.1.6 weak_ptr 420</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.2 动态数组 423</summary>
                  <blockquote>
                  12.2.1 new和数组 423</br>
                  12.2.2 allocator类 427</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.3 使用标准库：文本查询程序 430</summary>
                  <blockquote>
                  12.3.1 文本查询程序设计 430</br>
                  12.3.2 文本查询程序类的定义 432</br>
                  </blockquote>
              </details>
              小结 436</br>
              术语表 436</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第Ⅲ部分 类设计者的工具 437</summary>
          <blockquote>
          <details>
              <summary>第13章 拷贝控制 439</summary>
                  <blockquote>
                  <details>
                  <summary>13.1 拷贝、赋值与销毁 440</summary>
                      <blockquote>
                      13.1.1 拷贝构造函数 440</br>
                      13.1.2 拷贝赋值运算符 443</br>
                      13.1.3 析构函数 444</br>
                      13.1.4 三/五法则 447</br>
                      13.1.5 使用=default 449</br>
                      13.1.6 阻止拷贝 449</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>13.2 拷贝控制和资源管理 452</summary>
                      <blockquote>
                      13.2.1 行为像值的类 453</br>
                      13.2.2 定义行为像指针的类 455</br>
                      </blockquote>
                  </details>
                  13.3 交换操作 457</br>
                  13.4 拷贝控制示例 460</br>
                  13.5 动态内存管理类 464</br>
                  <details>
                  <summary>13.6 对象移动 470</summary>
                      <blockquote>
                      13.6.1 右值引用 471</br>
                      13.6.2 移动构造函数和移动赋值运算符 473</br>
                      13.6.3 右值引用和成员函数 481</br>
                      </blockquote>
                  </details>
                  小结 486</br>
                  术语表 486</br>
                  </blockquote>
              </details>
              <details>
              <summary>第14章 操作重载与类型转换 489</summary>
                  <blockquote>
                  14.1 基本概念 490</br>
                  <details>
                  <summary>14.2 输入和输出运算符 494</summary>
                      <blockquote>
                      14.2.1 重载输出运算符<< 494</br>
                      14.2.2 重载输入运算符>> 495</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>14.3 算术和关系运算符 497</summary>
                      <blockquote>
                      14.3.1 相等运算符 497</br>
                      14.3.2 关系运算符 498</br>
                      </blockquote>
                  </details>
                  14.4 赋值运算符 499</br>
                  14.5 下标运算符 501</br>
                  14.6 递增和递减运算符 502</br>
                  14.7 成员访问运算符 504</br>
                  <details>
                  <summary>14.8 函数调用运算符 506</summary>
                      <blockquote>
                      14.8.1 lambda是函数对象 507</br>
                      14.8.2 标准库定义的函数对象 509</br>
                      14.8.3 可调用对象与function 511</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>14.9 重载、类型转换与运算符 514</summary>
                      <blockquote>
                      14.9.1 类型转换运算符 514</br>
                      14.9.2 避免有二义性的类型转换 517</br>
                      14.9.3 函数匹配与重载运算符 521</br>
                      </blockquote>
                  </details>
                  小结 523</br>
                  术语表 523</br>
                  </blockquote>
              </details>
              <details>
              <summary>第15章 面向对象程序设计 525</summary>
                  <blockquote>
                  15.1 OOP：概述 526</br>
                  <details>
                  <summary>15.2 定义基类和派生类 527</summary>
                      <blockquote>
                      15.2.1 定义基类 528</br>
                      15.2.2 定义派生类 529</br>
                      15.2.3 类型转换与继承 534</br>
                      </blockquote>
                  </details>
                  15.3 虚函数 536</br>
                  15.4 抽象基类 540</br>
                  15.5 访问控制与继承 542</br>
                  15.6 继承中的类作用域 547</br>
                  <details>
                  <summary>15.7 构造函数与拷贝控制 551</summary>
                      <blockquote>
                      15.7.1 虚析构函数 552</br>
                      15.7.2 合成拷贝控制与继承 552</br>
                      15.7.3 派生类的拷贝控制成员 554</br>
                      15.7.4 继承的构造函数 557</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>15.8 容器与继承 558</summary>
                      <blockquote>
                      15.8.1 编写Basket类 559</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>15.9 文本查询程序再探 562</summary>
                      <blockquote>
                      15.9.1 面向对象的解决方案 563</br>
                      15.9.2 Query_base类和Query类 567</br>
                      15.9.3 派生类 568</br>
                      15.9.4 eval函数 571</br>
                      </blockquote>
                  </details>
                  小结 575</br>
                  术语表 575</br>
                  </blockquote>
              </details>
              <details>
              <summary>第16章 模板与泛型编程 577</summary>
                  <blockquote>
                  <details>
                  <summary>16.1 定义模板 578</summary>
                      <blockquote>
                      16.1.1 函数模板 578</br>
                      16.1.2 类模板 583</br>
                      16.1.3 模板参数 592</br>
                      16.1.4 成员模板 595</br>
                      16.1.5 控制实例化 597</br>
                      16.1.6 效率与灵活性 599</br>
                      </blockquote>
                  </details>
                  <details>
                  <summary>16.2 模板实参推断 600</summary>
                      <blockquote>
                      16.2.1 类型转换与模板类型参数 601</br>
                      16.2.2 函数模板显式实参 603</br>
                      16.2.3 尾置返回类型与类型转换 604</br>
                      16.2.4 函数指针和实参推断 607</br>
                      16.2.5 模板实参推断和引用 608</br>
                      16.2.6 理解std::move 610</br>
                      16.2.7 转发 612</br>
                      </blockquote>
                  </details>
                  16.3 重载与模板 614</br>
                  <details>
                  <summary>16.4 可变参数模板 618</summary>
                      <blockquote>
                      16.4.1 编写可变参数函数模板 620</br>
                      16.4.2 包扩展 621</br>
                      16.4.3 转发参数包 622</br>
                      </blockquote>
                  </details>
                  16.5 模板特例化 624</br>
                  小结 630</br>
                  术语表 630</br>
                  </blockquote>
              </details>
          </blockquote>
      </details>
      <details>
      <summary>第Ⅳ部分 高级主题 633</summary>
          <blockquote>
          <details>
          <summary>第17章 标准库特殊设施 635</summary>
              <blockquote>
              <details>
              <summary>17.1 tuple类型 636</summary>
                  <blockquote>
                  17.1.1 定义和初始化tuple 637</br>
                  17.1.2 使用tuple返回多个值 638</br>
                  </blockquote>
              </details>
              <details>
              <summary>17.2 BITSET类型 640</summary>
                  <blockquote>
                  17.2.1 定义和初始化bitset 641</br>
                  17.2.2 bitset操作 643</br>
                  </blockquote>
              </details>
              <details>
              <summary>17.3 正则表达式 645</summary>
                  <blockquote>
                  17.3.1 使用正则表达式库 646</br>
                  17.3.2 匹配与Regex迭代器类型 650</br>
                  17.3.3 使用子表达式 653</br>
                  17.3.4 使用regex_replace 657</br>
                  </blockquote>
              </details>
              <details>
              <summary>17.4 随机数 659</summary>
                  <blockquote>
                  17.4.2 其他随机数分布 663</br>
                  </blockquote>
              </details>
              bernoulli_distribution类 665</br>
              <details>
              <summary>17.5 IO库再探 666</summary>
                  <blockquote>
                  17.5.1 格式化输入与输出 666</br>
                  17.5.2 未格式化的输入/输出操作 673</br>
                  17.5.3 流随机访问 676</br>
                  </blockquote>
              </details>
              小结 680</br>
              术语表 680</br>
              </blockquote>
          </details>
          <details>
          <summary>第18章 用于大型程序的工具 683</summary>
              <blockquote>
              <details>
              <summary>18.1 异常处理 684</summary>
                  <blockquote>
                  18.1.1 抛出异常 684</br>
                  18.1.2 捕获异常 687</br>
                  18.1.3 函数try语句块与构造函数 689</br>
                  18.1.4 noexcept异常说明 690</br>
                  18.1.5 异常类层次 693</br>
                  </blockquote>
              </details>
              <details>
              <summary>18.2 命名空间 695</summary>
                  <blockquote>
                  18.2.1 命名空间定义 695</br>
                  18.2.2 使用命名空间成员 701</br>
                  18.2.3 类、命名空间与作用域 705</br>
                  18.2.4 重载与命名空间 708</br>
                  </blockquote>
              </details>
              <details>
              <summary>18.3 多重继承与虚继承 710</summary>
                  <blockquote>
                  18.3.1 多重继承 711</br>
                  18.3.2 类型转换与多个基类 713</br>
                  18.3.3 多重继承下的类作用域 715</br>
                  18.3.4 虚继承 717</br>
                  18.3.5 构造函数与虚继承 720</br>
                  </blockquote>
              </details>
              小结 722</br>
              术语表 722</br>
              </blockquote>
          </details>
          <details>
          <summary>第19章 特殊工具与技术 725</summary>
              <blockquote>
              <details>
              <summary>19.1 控制内存分配 726</summary>
                  <blockquote>
                  19.1.1 重载new和delete 726</br>
                  19.1.2 定位new表达式 729</br>
                  </blockquote>
              </details>
              <details>
              <summary>19.2 运行时类型识别 730</summary>
                  <blockquote>
                  19.2.1 dynamic_cast运算符 730</br>
                  19.2.2 typeid运算符 732</br>
                  19.2.3 使用RTTI 733</br>
                  19.2.4 type_info类 735</br>
                  </blockquote>
              </details>
              19.3 枚举类型 736</br>
              <details>
              <summary>19.4 类成员指针 739</summary>
                  <blockquote>
                  19.4.1 数据成员指针 740</br>
                  19.4.2 成员函数指针 741</br>
                  19.4.3 将成员函数用作可调用对象 744</br>
                  </blockquote>
              </details>
              19.5 嵌套类 746</br>
              19.6 union：一种节省空间的类 749</br>
              19.7 局部类 754</br>
              <details>
              <summary>19.8 固有的不可移植的特性 755</summary>
                  <blockquote>
                  19.8.1 位域 756</br>
                  19.8.2 volatile限定符 757</br>
                  19.8.3 链接指示：extern "C" 758</br>
                  </blockquote>
              </details>
              小结 762</br>
              术语表 762</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>附录A 标准库 765</summary>
          <blockquote>
          A.1 标准库名字和头文件 766</br>
          <details>
          <summary>A.2 算法概览 770</summary>
              <blockquote>
              A.2.1 查找对象的算法 771</br>
              A.2.2 其他只读算法 772</br>
              A.2.3 二分搜索算法 772</br>
              A.2.4 写容器元素的算法 773</br>
              A.2.5 划分与排序算法 775</br>
              A.2.6 通用重排操作 776</br>
              A.2.7 排列算法 778</br>
              A.2.8 有序序列的集合算法 778</br>
              A.2.9 最小值和最大值 779</br>
              A.2.10 数值算法 780</br>
              </blockquote>
          </details>
          <details>
          <summary>A.3 随机数 781</summary>
              <blockquote>
              A.3.1 随机数分布 781</br>
              A.3.2 随机数引擎 783</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>C++11的新特性</summary>
          <blockquote>
          2.1.1 long long类型 31</br>
          2.2.1 列表初始化 39</br>
          2.3.2 nullptr常量 48</br>
          2.4.4 constexpr变量 59</br>
          2.5.1 类型别名声明 60</br>
          2.5.2 auto类型指示符 61</br>
          2.5.3 decltype类型指示符 62</br>
          2.6.1 类内初始化 65</br>
          3.2.2 使用auto或decltype缩写类型 79</br>
          3.2.3 范围for语句 82</br>
          <details>
          <summary>3.3 定义vector对象的vector（向量的向量） 87</summary>
              <blockquote>
              3.3.1 vector对象的列表初始化 88</br>
              </blockquote>
          </details>
          3.4.1 容器的cbegin和cend函数 98</br>
          3.5.3 标准库begin和end函数 106</br>
          3.6 使用auto和decltype简化声明 115</br>
          4.2 除法的舍入规则 125</br>
          4.4 用大括号包围的值列表赋值 129</br>
          4.9 将sizeof用于类成员 139</br>
          5.4.3 范围for语句 168</br>
          6.2.6 标准库initializer_list类 197</br>
          6.3.2 列表初始化返回值 203</br>
          <details>
          <summary>6.3.3 定义尾置返回类型 206</summary>
              <blockquote>
              6.3.3 使用decltype简化返回类型定义</br>
              </blockquote>
          </details>
          6.5.2 constexpr函数 214</br>
          7.1.4 使用=default生成默认构造函数 237</br>
          7.3.1 类对象成员的类内初始化 246</br>
          7.5.2 委托构造函数 261</br>
          7.5.6 constexpr构造函数 268</br>
          8.2.1 用string对象处理文件名 284</br>
          9.1 array和forward_list容器 293</br>
          9.2.3 容器的cbegin和cend函数 298</br>
          9.2.4 容器的列表初始化 300</br>
          9.2.5 容器的非成员函数swap 303</br>
          <details>
          <summary>9.3.1 容器insert成员的返回类型 308</summary>
              <blockquote>
              9.3.1 容器的emplace成员的返回类型 308</br>
              </blockquote>
          </details>
          9.4 shrink_to_fit 318</br>
          9.5.5 string的数值转换函数 327</br>
          10.3.2 Lambda表达式 346</br>
          10.3.3 Lambda表达式中的尾置返回类型 353</br>
          10.3.4 标准库bind函数 354</br>
          11.2.1 关联容器的列表初始化 377</br>
          11.2.3 列表初始化pair的返回类型 380</br>
          11.3.2 pair的列表初始化 384</br>
          11.4 无序容器 394</br>
          <details>
          <summary>12.1 智能指针 400</summary>
              <blockquote>
              12.1.1 shared_ptr类</br>
              <details>
              <summary>12.1.2 动态分配对象的列表初始化 407</summary>
                  <blockquote>
                  12.1.2 auto和动态分配 408</br>
                  </blockquote>
              </details>
              12.1.5 unique_ptr类 417</br>
              12.1.6 weak_ptr类 420</br>
              </blockquote>
          </details>
          <details>
          <summary>12.2.1 范围for语句不能应用于动态分配数组 424</summary>
              <blockquote>
              <details>
              <summary>12.2.1 动态分配数组的列表初始化 424</summary>
                  <blockquote>
                  12.2.1 auto不能用于分配数组 424</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          12.2.2 allocator::construct可使用任意构造函数 428</br>
          13.1.5 将=default用于拷贝控制成员 449</br>
          13.1.6 使用=default阻止拷贝类对象 449</br>
          13.5 用移动类对象代替拷贝类对象 469</br>
          <details>
          <summary>13.6.1 右值引用 471</summary>
              <blockquote>
              13.6.1 标准库move函数 472</br>
              </blockquote>
          </details>
          <details>
          <summary>13.6.2 移动构造函数和移动赋值 473</summary>
              <blockquote>
              <details>
              <summary>13.6.2 移动构造函数通常应该是noexcept 473</summary>
                  <blockquote>
                  13.6.2 移动迭代器 480</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          13.6.3 引用限定成员函数 483</br>
          14.8.3 function类模板 512</br>
          14.9.1 explicit类型转换运算符 516</br>
          <details>
          <summary>15.2.2 虚函数的override指示符 530</summary>
              <blockquote>
              15.2.2 通过定义类为final来阻止继承 533</br>
              </blockquote>
          </details>
          15.3 虚函数的override和final指示符 538</br>
          15.7.2 删除的拷贝控制和继承 553</br>
          15.7.4 继承的构造函数 557</br>
          <details>
          <summary>16.1.2 声明模板类型形参为友元 590</summary>
              <blockquote>
              16.1.2 模板类型别名 590</br>
              </blockquote>
          </details>
          16.1.3 模板函数的默认模板参数 594</br>
          16.1.5 实例化的显式控制 597</br>
          16.2.3 模板函数与尾置返回类型 605</br>
          16.2.5 引用折叠规则 609</br>
          16.2.6 用static_cast将左值转换为右值 612</br>
          16.2.7 标准库forward函数 614</br>
          <details>
          <summary>16.4 可变参数模板 618</summary>
              <blockquote>
              <details>
              <summary>16.4 sizeof...运算符 619</summary>
                  <blockquote>
                  16.4.3 可变参数模板与转发 622</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          17.1 标准库Tuple类模板 636</br>
          17.2.2 新的bitset运算 643</br>
          17.3 正则表达式库 645</br>
          17.4 随机数库 659</br>
          17.5.1 浮点数格式控制 670</br>
          <details>
          <summary>18.1.4 noexcept异常指示符 690</summary>
              <blockquote>
              18.1.4 noexcept运算符 691</br>
              </blockquote>
          </details>
          18.2.1 内联名字空间 699</br>
          18.3.1 继承的构造函数和多重继承 712</br>
          <details>
          <summary>19.3 有作用域的enum 736</summary>
              <blockquote>
              <details>
              <summary>19.3 说明类型用于保存enum对象 738</summary>
                  <blockquote>
                  19.3 enum的提前声明 738</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          19.4.3 标准库mem_fn类模板 746</br>
          19.6 类类型的联合成员 751</br>
          </blockquote>
      </details>
      </blockquote>
  </details></li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><ul>
<li>《C#程序设计经典教程》</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li>《Java程序设计教程》</li>
<li>《Java语言程序设计——基础篇》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章 计算机、程序和Java概述1</summary>
          <blockquote>
          1.1 引言1</br>
          <details>
          <summary>1.2 什么是计算机2</summary>
              <blockquote>
              1.2.1 中央处理器2</br>
              1.2.2 比特和字节3</br>
              1.2.3 内存3</br>
              1.2.4 存储设备4</br>
              1.2.5 输入和输出设备4</br>
              1.2.6 通信设备5</br>
              </blockquote>
          </details>
          <details>
          <summary>1.3 编程语言6</summary>
              <blockquote>
              1.3.1 机器语言6</br>
              1.3.2 汇编语言6</br>
              1.3.3 高级语言7</br>
              </blockquote>
          </details>
          <details>
          <summary>1.4 操作系统8</summary>
              <blockquote>
              1.4.1 控制和监视系统的活动8</br>
              1.4.2 分配和调配系统资源8</br>
              1.4.3 调度操作8</br>
              </blockquote>
          </details>
          1.5 Java、万维网以及其他9</br>
          1.6 Java语言规范、API、JDK和IDE10</br>
          1.7 一个简单的Java程序11</br>
          1.8 创建、编译和执行Java程序13</br>
          <details>
          <summary>1.9 程序设计风格和文档16</summary>
              <blockquote>
              1.9.1 正确的注释和注释风格16</br>
              1.9.2 正确的缩进和空白16</br>
              1.9.3 块的风格17</br>
              </blockquote>
          </details>
          <details>
          <summary>1.10 程序设计错误17</summary>
              <blockquote>
              1.10.1 语法错误17</br>
              1.10.2 运行时错误18</br>
              1.10.3 逻辑错误18</br>
              1.10.4 常见错误19</br>
              </blockquote>
          </details>
          <details>
          <summary>1.11 使用NetBeans开发Java程序20</summary>
              <blockquote>
              1.11.1 创建Java工程20</br>
              1.11.2 创建Java类21</br>
              1.11.3 编译和运行类22</br>
              </blockquote>
          </details>
          <details>
          <summary>1.12 使用Eclipse开发Java程序22</summary>
              <blockquote>
              1.12.1 创建Java工程22</br>
              1.12.2 创建Java类24</br>
              1.12.3 编译和运行类24</br>
              </blockquote>
          </details>
          关键术语25</br>
          本章小结25</br>
          测试题26</br>
          编程练习题26</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章 基本程序设计28</summary>
          <blockquote>
          2.1 引言28</br>
          2.2 编写简单的程序28</br>
          2.3 从控制台读取输入31</br>
          2.4 标识符34</br>
          2.5 变量34</br>
          2.6 赋值语句和赋值表达式36</br>
          2.7 命名常量37</br>
          2.8 命名习惯37</br>
          <details>
          <summary>2.9 数值数据类型和操作38</summary>
              <blockquote>
              2.9.1 数值类型38</br>
              2.9.2 从键盘读取数值39</br>
              2.9.3 数值操作符39</br>
              2.9.4 幂运算41</br>
              </blockquote>
          </details>
          <details>
          <summary>2.10 数值型直接量41</summary>
              <blockquote>
              2.10.1 整型直接量42</br>
              2.10.2 浮点型直接量42</br>
              2.10.3 科学记数法42</br>
              </blockquote>
          </details>
          2.11 表达式求值以及操作符优先级43</br>
          2.12 示例学习：显示当前时间44</br>
          2.13 增强赋值操作符46</br>
          2.14 自增和自减操作符47</br>
          2.15 数值类型转换48</br>
          2.16 软件开发过程50</br>
          2.17 示例学习：整钱兑零54</br>
          2.18 常见错误和陷阱56</br>
          关键术语58</br>
          本章小结58</br>
          测试题59</br>
          编程练习题59</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章 选择64</summary>
          <blockquote>
          3.1 引言64</br>
          3.2 boolean数据类型64</br>
          3.3 if语句66</br>
          3.4 双分支if—else语句68</br>
          3.5 嵌套的if语句和多分支if—else语句69</br>
          3.6 常见错误和陷阱71</br>
          3.7 产生随机数74</br>
          3.8 示例学习：计算身体质量指数76</br>
          3.9 示例学习：计算税率77</br>
          3.10 逻辑操作符80</br>
          3.11 示例学习：判定闰年83</br>
          3.12 示例学习：彩票84</br>
          3.13 switch语句85</br>
          3.14 条件表达式88</br>
          3.15 操作符的优先级和结合规则89</br>
          3.16 调试90</br>
          关键术语91</br>
          本章小结91</br>
          测试题92</br>
          编程练习题92</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章 数学函数、字符和字符串100</summary>
          <blockquote>
          4.1 引言100</br>
          <details>
          <summary>4.2 常用数学函数101</summary>
              <blockquote>
              4.2.1 三角函数方法101</br>
              4.2.2 指数函数方法102</br>
              4.2.3 取整方法102</br>
              4.2.4 min、max和abs方法102</br>
              4.2.5 random方法103</br>
              4.2.6 示例学习：计算三角形的角度103</br>
              </blockquote>
          </details>
          <details>
          <summary>4.3 字符数据类型和操作105</summary>
              <blockquote>
              4.3.1 Unicode和ASCII码105</br>
              4.3.2 特殊字符的转义序列106</br>
              4.3.3 字符型数据与数值型数据之间的转换107</br>
              4.3.4 字符的比较和测试107</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4 String类型109</summary>
              <blockquote>
              4.4.1 求字符串长度110</br>
              4.4.2 从字符串中获取字符110</br>
              4.4.3 连接字符串111</br>
              4.4.4 字符串的转换111</br>
              4.4.5 从控制台读取字符串112</br>
              4.4.6 从控制台读取字符112</br>
              4.4.7 字符串比较112</br>
              4.4.8 获得子字符串114</br>
              4.4.9 获取字符串中的字符或者子串115</br>
              4.4.10 字符串和数字间的转换116</br>
              </blockquote>
          </details>
          <details>
          <summary>4.5 示例学习117</summary>
              <blockquote>
              4.5.1 猜测生日118</br>
              4.5.2 将十六进制数转换为十进制数121</br>
              4.5.3 使用字符串修改彩票程序122</br>
              </blockquote>
          </details>
          4.6 格式化控制台输出123</br>
          关键术语126</br>
          本章小结127</br>
          测试题127</br>
          编程练习题127</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章 循环133</summary>
          <blockquote>
          5.1 引言133</br>
          <details>
          <summary>5.2 while循环134</summary>
              <blockquote>
              5.2.1 示例学习：猜数字136</br>
              5.2.2 循环设计策略138</br>
              5.2.3 示例学习：多个减法测试题138</br>
              5.2.4 使用标记值控制循环140</br>
              5.2.5 输入和输出重定向141</br>
              </blockquote>
          </details>
          5.3 do—while循环143</br>
          5.4 for循环144</br>
          5.5 采用哪种循环147</br>
          5.6 嵌套循环149</br>
          5.7 最小化数值错误151</br>
          <details>
          <summary>5.8 示例学习152</summary>
              <blockquote>
              5.8.1 求最大公约数152</br>
              5.8.2 预测未来学费154</br>
              5.8.3 将十进制数转换为十六进制数155</br>
              </blockquote>
          </details>
          5.9 关键字break和continue156</br>
          5.10 示例学习：判断回文串159</br>
          5.11 示例学习：显示素数160</br>
          关键术语162</br>
          本章小结163</br>
          测试题163</br>
          编程练习题163</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章 方法171</summary>
          <blockquote>
          6.1 引言171</br>
          6.2 定义方法172</br>
          6.3 调用方法173</br>
          6.4 void方法示例175</br>
          6.5 通过传值进行参数传递178</br>
          6.6 模块化代码181</br>
          6.7 示例学习：将十六进制数转换为十进制数183</br>
          6.8 重载方法185</br>
          6.9 变量的作用域187</br>
          6.10 示例学习：生成随机字符188</br>
          <details>
          <summary>6.11 方法抽象和逐步求精190</summary>
              <blockquote>
              6.11.1 自顶向下的设计191</br>
              6.11.2 自顶向下和自底向上的实现192</br>
              6.11.3 实现细节193</br>
              6.11.4 逐步求精的优势196</br>
              </blockquote>
          </details>
          关键术语196</br>
          本章小结197</br>
          测试题197</br>
          编程练习题197</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章 一维数组207</summary>
          <blockquote>
          7.1 引言207</br>
          <details>
          <summary>7.2 数组的基础知识207</summary>
              <blockquote>
              7.2.1 声明数组变量208</br>
              7.2.2 创建数组208</br>
              7.2.3 数组大小和默认值209</br>
              7.2.4 访问数组元素209</br>
              7.2.5 数组初始化语法210</br>
              7.2.6 处理数组210</br>
              7.2.7 foreach循环212</br>
              </blockquote>
          </details>
          7.3 示例学习：分析数字214</br>
          7.4 示例学习：一副牌215</br>
          7.5 数组的复制217</br>
          7.6 将数组传递给方法218</br>
          7.7 从方法中返回数组221</br>
          7.8 示例学习：统计每个字母出现的次数221</br>
          7.9 可变长参数列表224</br>
          <details>
          <summary>7.10 数组的查找225</summary>
              <blockquote>
              7.10.1 线性查找法225</br>
              7.10.2 二分查找法226</br>
              </blockquote>
          </details>
          7.11 数组的排序228</br>
          7.12 Arrays类230</br>
          <details>
          <summary>7.13 命令行参数232</summary>
              <blockquote>
              7.13.1 向main方法传递字符串232</br>
              7.13.2 示例学习：计算器232</br>
              </blockquote>
          </details>
          关键术语234</br>
          本章小结235</br>
          测试题235</br>
          编程练习题235</br>
          </blockquote>
      </details>
      <details>
      <summary>第8章 多维数组242</summary>
          <blockquote>
          8.1 引言242</br>
          <details>
          <summary>8.2 二维数组的基础知识242</summary>
              <blockquote>
              8.2.1 声明二维数组变量并创建二维数组243</br>
              8.2.2 获取二维数组的长度244</br>
              8.2.3 锯齿数组244</br>
              </blockquote>
          </details>
          8.3 处理二维数组245</br>
          8.4 将二维数组传递给方法247</br>
          8.5 示例学习：多选题测验评分248</br>
          8.6 示例学习：找出距离最近的点对249</br>
          8.7 示例学习：数独251</br>
          <details>
          <summary>8.8 多维数组254</summary>
              <blockquote>
              8.8.1 示例学习：每日温度和湿度255</br>
              8.8.2 示例学习：猜生日256</br>
              </blockquote>
          </details>
          本章小结258</br>
          测试题258</br>
          编程练习题258</br>
          </blockquote>
      </details>
      <details>
      <summary>第9章 对象和类270</summary>
          <blockquote>
          9.1 引言270</br>
          9.2 为对象定义类270</br>
          9.3 示例：定义类和创建对象272</br>
          9.4 使用构造方法构造对象277</br>
          <details>
          <summary>9.5 通过引用变量访问对象278</summary>
              <blockquote>
              9.5.1 引用变量和引用类型278</br>
              9.5.2 访问对象的数据和方法279</br>
              9.5.3 引用数据域和null值279</br>
              9.5.4 基本类型变量和引用类型变量的区别280</br>
              </blockquote>
          </details>
          <details>
          <summary>9.6 使用Java库中的类282</summary>
              <blockquote>
              9.6.1 Date类282</br>
              9.6.2 Random类283</br>
              9.6.3 Point2D类283</br>
              </blockquote>
          </details>
          9.7 静态变量、常量和方法284</br>
          9.8 可见性修饰符289</br>
          9.9 数据域封装291</br>
          9.10 向方法传递对象参数294</br>
          9.11 对象数组297</br>
          9.12 不可变对象和类299</br>
          9.13 变量的作用域301</br>
          <details>
          <summary>9.14 this引用302</summary>
              <blockquote>
              9.14.1 使用this引用隐藏数据域302</br>
              9.14.2 使用this调用构造方法303</br>
              </blockquote>
          </details>
          关键术语304</br>
          本章小结304</br>
          测试题305</br>
          编程练习题305</br>
          </blockquote>
      </details>
      <details>
      <summary>第10章 面向对象思考309</summary>
          <blockquote>
          10.1 引言309</br>
          10.2 类的抽象和封装309</br>
          10.3 面向对象的思考313</br>
          <details>
          <summary>10.4 类的关系315</summary>
              <blockquote>
              10.4.1 关联316</br>
              10.4.2 聚集和组合317</br>
              </blockquote>
          </details>
          10.5 示例学习：设计Course类318</br>
          10.6 示例学习：设计栈类320</br>
          10.7 将基本数据类型值作为对象处理322</br>
          10.8 基本类型和包装类类型之间的自动转换325</br>
          10.9 BigInteger和BigDecimal类326</br>
          <details>
          <summary>10.10 String类327</summary>
              <blockquote>
              10.10.1 构造字符串327</br>
              10.10.2 不可变字符串与限定字符串328</br>
              10.10.3 字符串的替换和分隔329</br>
              10.10.4 依照模式匹配、替换和分隔329</br>
              10.10.5 字符串与数组之间的转换330</br>
              10.10.6 将字符和数值转换成字符串331</br>
              10.10.7 格式化字符串331</br>
              </blockquote>
          </details>
          <details>
          <summary>10.11 StringBuilder和StringBuffer类333</summary>
              <blockquote>
              10.11.1 修改StringBuilder中的字符串334</br>
              10.11.2 toString、capacity、length、setLength和charAt方法335</br>
              10.11.3 示例学习：判断回文串时忽略既非字母又非数字的字符336</br>
              </blockquote>
          </details>
          关键术语338</br>
          本章小结339</br>
          测试题339</br>
          编程练习题339</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章 继承和多态347</summary>
          <blockquote>
          11.1 引言347</br>
          11.2 父类和子类347</br>
          <details>
          <summary>11.3 使用super关键字353</summary>
              <blockquote>
              11.3.1 调用父类的构造方法353</br>
              11.3.2 构造方法链354</br>
              11.3.3 调用父类的方法355</br>
              </blockquote>
          </details>
          11.4 方法重写356</br>
          11.5 方法重写与重载357</br>
          11.6 Object类及其toString（）方法359</br>
          11.7 多态359</br>
          11.8 动态绑定360</br>
          11.9 对象转换和instanceof运算符363</br>
          11.10 Object类的equals方法367</br>
          11.11 ArrayList类368</br>
          11.12 对于列表有用的方法374</br>
          11.13 示例学习：自定义栈类374</br>
          11.14 protected数据和方法376</br>
          11.15 防止扩展和重写378</br>
          关键术语378</br>
          本章小结379</br>
          测试题379</br>
          编程练习题380</br>
          </blockquote>
      </details>
      <details>
      <summary>第12章 异常处理和文本I/O384</summary>
          <blockquote>
          12.1 引言384</br>
          12.2 异常处理概述385</br>
          12.3 异常类型389</br>
          <details>
          <summary>12.4 关于异常处理的更多知识391</summary>
              <blockquote>
              12.4.1 声明异常392</br>
              12.4.2 抛出异常392</br>
              12.4.3 捕获异常393</br>
              12.4.4 从异常中获取信息394</br>
              12.4.5 示例学习：声明、抛出和捕获异常396</br>
              </blockquote>
          </details>
          12.5 finally子句399</br>
          12.6 何时使用异常400</br>
          12.7 重新抛出异常401</br>
          12.8 链式异常402</br>
          12.9 创建自定义异常类403</br>
          12.10 File类405</br>
          <details>
          <summary>12.11 文件输入和输出408</summary>
              <blockquote>
              12.11.1 使用PrintWriter写数据408</br>
              12.11.2 使用try—with—resources自动关闭资源409</br>
              12.11.3 使用Scanner读数据410</br>
              12.11.4 Scanner如何工作411</br>
              12.11.5 示例学习：替换文本412</br>
              </blockquote>
          </details>
          12.12 从Web上读取数据414</br>
          12.13 示例学习：Web爬虫416</br>
          关键术语418</br>
          本章小结418</br>
          测试题419</br>
          编程练习419</br>
          </blockquote>
      </details>
      <details>
      <summary>第13章 抽象类和接口424</summary>
          <blockquote>
          13.1 引言424</br>
          <details>
          <summary>13.2 抽象类424</summary>
              <blockquote>
              13.2.1 为何要使用抽象方法427</br>
              13.2.2 抽象类的几点说明428</br>
              </blockquote>
          </details>
          13.3 示例学习：抽象的Number类429</br>
          13.4 示例学习：Calendar和GregorianCalendar431</br>
          13.5 接口434</br>
          13.6 Comparable接口436</br>
          13.7 Cloneable接口440</br>
          13.8 接口与抽象类444</br>
          13.9 示例学习：Rational类447</br>
          <details>
          <summary>13.10 类的设计原则452</summary>
              <blockquote>
              13.10.1 内聚性452</br>
              13.10.2 一致性452</br>
              13.10.3 封装性452</br>
              13.10.4 清晰性453</br>
              13.10.5 完整性453</br>
              13.10.6 实例和静态453</br>
              13.10.7 继承与聚合454</br>
              13.10.8 接口和抽象类454</br>
              </blockquote>
          </details>
          关键术语454</br>
          本章小结455</br>
          测试题455</br>
          编程练习题455</br>
          </blockquote>
      </details>
      <details>
      <summary>第14章 JavaFX基础459</summary>
          <blockquote>
          14.1 引言459</br>
          14.2 JavaFX与Swing以及AWT的比较459</br>
          14.3 JavaFX程序的基本结构460</br>
          14.4 面板、UI组件以及形状462</br>
          14.5 属性绑定465</br>
          14.6 节点的通用属性和方法468</br>
          14.7 Color类469</br>
          14.8 Font类470</br>
          14.9 Image和ImageView类472</br>
          <details>
          <summary>14.10 布局面板474</summary>
              <blockquote>
              14.10.1 FlowPane475</br>
              14.10.2 GridPane477</br>
              14.10.3 BorderPane478</br>
              14.10.4 HBox和VBox480</br>
              </blockquote>
          </details>
          <details>
          <summary>14.11 形状482</summary>
              <blockquote>
              14.11.1 Text482</br>
              14.11.2 Line484</br>
              14.11.3 Rectangle485</br>
              14.11.4 Circle和Ellipse487</br>
              14.11.5 Arc488</br>
              14.11.6 Polygon和Polyline491</br>
              </blockquote>
          </details>
          14.12 示例学习：ClockPane类493</br>
          关键术语497</br>
          本章小结498</br>
          测试题498</br>
          编程练习题498</br>
          </blockquote>
      </details>
      <details>
      <summary>第15章 事件驱动编程和动画504</summary>
          <blockquote>
          15.1 引言504</br>
          15.2 事件和事件源506</br>
          15.3 注册处理器和处理事件507</br>
          15.4 内部类511</br>
          15.5 匿名内部类处理器512</br>
          15.6 使用lambda表达式简化事件处理514</br>
          15.7 示例学习：贷款计算器517</br>
          15.8 鼠标事件519</br>
          15.9 键盘事件520</br>
          15.10 可观察对象的监听器523</br>
          <details>
          <summary>15.11 动画525</summary>
              <blockquote>
              15.11.1 PathTransition525</br>
              15.11.2 FadeTransition528</br>
              15.11.3 Timeline530</br>
              </blockquote>
          </details>
          15.12 示例学习：弹球532</br>
          关键术语535</br>
          本章小结535</br>
          测试题536</br>
          编程练习题536</br>
          </blockquote>
      </details>
      <details>
      <summary>第16章 JavaFXUI组件和多媒体542</summary>
          <blockquote>
          16.1 引言542</br>
          16.2 Labeled和Label543</br>
          16.3 按钮545</br>
          16.4 复选框547</br>
          16.5 单选按钮549</br>
          16.6 文本域551</br>
          16.7 文本区域553</br>
          16.8 组合框556</br>
          16.9 列表视图559</br>
          16.10 滚动条562</br>
          16.11 滑动条564</br>
          16.12 示例学习：开发一个井字游戏567</br>
          16.13 视频和音频572</br>
          16.14 示例学习：国旗和国歌575</br>
          本章小结577</br>
          测试题578</br>
          编程练习题578</br>
          </blockquote>
      </details>
      <details>
      <summary>第17章 二进制I/O584</summary>
          <blockquote>
          17.1 引言584</br>
          17.2 在Java中如何处理文本I/O584</br>
          17.3 文本I/O与二进制I/O585</br>
          <details>
          <summary>17.4 二进制I/O类587</summary>
              <blockquote>
              17.4.1 FileInputStream和FileOutputStream588</br>
              17.4.2 FilterInputStream和FilterOutputStream590</br>
              17.4.3 DataInputStream和DataOutputStream590</br>
              17.4.4 BufferedInputStream和BufferedOutputStream594</br>
              </blockquote>
          </details>
          17.5 示例学习：复制文件596</br>
          <details>
          <summary>17.6 对象I/O598</summary>
              <blockquote>
              17.6.1 Serializable接口600</br>
              17.6.2 序列化数组601</br>
              </blockquote>
          </details>
          17.7 随机访问文件602</br>
          关键术语606</br>
          本章小结606</br>
          测试题606</br>
          编程练习题606</br>
          </blockquote>
      </details>
      <details>
      <summary>第18章 递归609</summary>
          <blockquote>
          18.1 引言609</br>
          18.2 示例学习：计算阶乘610</br>
          18.3 示例学习：计算斐波那契数613</br>
          18.4 使用递归解决问题615</br>
          <details>
          <summary>18.5 递归辅助方法617</summary>
              <blockquote>
              18.5.1 递归选择排序618</br>
              18.5.2 递归二分查找618</br>
              </blockquote>
          </details>
          18.6 示例学习：得到目录的大小619</br>
          18.7 示例学习：汉诺塔621</br>
          18.8 示例学习：分形624</br>
          18.9 递归与迭代627</br>
          18.10 尾递归628</br>
          关键术语629</br>
          本章小结629</br>
          测试题630</br>
          编程练习题630</br>
          </blockquote>
      </details>
      <details>
      <summary>附录A Java关键字637</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录B ASCII字符集638</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录C 操作符优先级表639</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录D Java修饰符640</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录E 特殊浮点值641</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录F 数系642</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录G 位操作646</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录H 正则表达式647</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录I 枚举类型651</summary>
      </details>
      </blockquote>
  </details></li>
<li>《Java语言程序设计——进阶篇》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第19章　泛型 1</summary>
          <blockquote>
          19.1　引言 1</br>
          19.2　动机和优点 1</br>
          19.3　定义泛型类和接口 4</br>
          19.4　泛型方法 5</br>
          19.5　示例学习：对一个对象数组进行排序 7</br>
          19.6　原始类型和向后兼容 8</br>
          19.7　通配泛型 10</br>
          19.8　消除泛型和对泛型的限制 12</br>
          19.9　示例学习：泛型矩阵类 15</br>
          关键术语 19</br>
          本章小结 19</br>
          测试题 20</br>
          编程练习题 20</br>
          </blockquote>
      </details>
      <details>
      <summary>第20章　线性表、栈、队列和优先队列 21</summary>
          <blockquote>
          20.1　引言 21</br>
          20.2　合集 21</br>
          20.3　迭代器 25</br>
          <details>
          <summary>20.4　线性表 26</summary>
              <blockquote>
              20.4.1　List接口中的通用方法 26</br>
              20.4.2　数组线性表类ArrayList和链表类LinkedList 27</br>
              </blockquote>
          </details>
          20.5　Comparator接口 30</br>
          20.6　线性表和合集的静态方法 32</br>
          20.7　示例学习：弹球 35</br>
          20.8　向量类和栈类 38</br>
          <details>
          <summary>20.9　队列和优先队列 40</summary>
              <blockquote>
              20.9.1　Queue接口 40</br>
              20.9.2　双端队列Deque和链表LinkedList 40</br>
              </blockquote>
          </details>
          20.10　示例学习：表达式求值 43</br>
          关键术语 47</br>
          本章小结 47</br>
          测试题 47</br>
          编程练习题 47</br>
          </blockquote>
      </details>
      <details>
      <summary>第21章　集合和映射表 53</summary>
          <blockquote>
          21.1　引言 53</br>
          <details>
          <summary>21.2　集合 53</summary>
              <blockquote>
              21.2.1　HashSet 54</br>
              21.2.2　LinkedHashSet 57</br>
              21.2.3　TreeSet 58</br>
              </blockquote>
          </details>
          21.3　比较集合和线性表的性能 61</br>
          21.4　示例学习：统计关键字 63</br>
          21.5　映射表 65</br>
          21.6　示例学习：单词的出现次数 69</br>
          21.7　单元素与不可变的合集和映射表 71</br>
          关键术语 72</br>
          本章小结 72</br>
          测试题 72</br>
          编程练习题 72</br>
          </blockquote>
      </details>
      <details>
      <summary>第22章　开发高效算法 75</summary>
          <blockquote>
          22.1　引言 75</br>
          22.2　使用大O符号来衡量算法效率 75</br>
          22.3　示例：确定大O 77</br>
          <details>
          <summary>22.4　分析算法的时间复杂度 81</summary>
              <blockquote>
              22.4.1　分析二分查找算法 81</br>
              22.4.2　分析选择排序算法 81</br>
              22.4.3　分析汉诺塔问题 81</br>
              22.4.4　常用的递推关系 82</br>
              22.4.5　比较常用的增长函数 82</br>
              </blockquote>
          </details>
          22.5　使用动态编程计算斐波那契数 83</br>
          22.6　使用欧几里得算法求最大公约数 85</br>
          22.7　寻找素数的高效算法 89</br>
          22.8　使用分而治之法寻找最近的点对 94</br>
          22.9　使用回溯法解决八皇后问题 97</br>
          <details>
          <summary>22.10　计算几何：寻找凸包 99</summary>
              <blockquote>
              22.10.1　卷包裹算法 100</br>
              22.10.2　格雷厄姆算法 101</br>
              </blockquote>
          </details>
          关键术语 102</br>
          本章小结 102</br>
          测试题 103</br>
          编程练习题 103</br>
          </blockquote>
      </details>
      <details>
      <summary>第23章　排序 109</summary>
          <blockquote>
          23.1　引言 109</br>
          23.2　插入排序 110</br>
          23.3　冒泡排序 112</br>
          23.4　归并排序 114</br>
          23.5　快速排序 117</br>
          <details>
          <summary>23.6　堆排序 121</summary>
              <blockquote>
              23.6.1　堆的存储 122</br>
              23.6.2　添加一个新的结点 122</br>
              23.6.3　删除根结点 123</br>
              23.6.4　Heap类 124</br>
              23.6.5　使用Heap类进行排序 126</br>
              23.6.6　堆排序的时间复杂度 127</br>
              </blockquote>
          </details>
          23.7　桶排序和基数排序 128</br>
          <details>
          <summary>23.8　外部排序 129</summary>
              <blockquote>
              23.8.1　实现阶段Ⅰ 131</br>
              23.8.2　实现阶段Ⅱ 132</br>
              23.8.3　结合两个阶段 133</br>
              23.8.4　外部排序复杂度 136</br>
              </blockquote>
          </details>
          关键术语 136</br>
          本章小结 136</br>
          测试题 137</br>
          编程练习题 137</br>
          </blockquote>
      </details>
      <details>
      <summary>第24章　实现线性表、栈、队列和优先队列 141</summary>
          <blockquote>
          24.1　引言 141</br>
          24.2　线性表的通用特性 141</br>
          24.3　数组线性表 144</br>
          <details>
          <summary>24.4　链表 151</summary>
              <blockquote>
              24.4.1　结点 151</br>
              24.4.2　MyLinkedList类 153</br>
              24.4.3　实现MyLinkedList 154</br>
              24.4.4　MyArrayList和MyLinkedList 162</br>
              24.4.5　链表的变体 162</br>
              </blockquote>
          </details>
          24.5　栈和队列 163</br>
          24.6　优先队列 167</br>
          本章小结 168</br>
          测试题 169</br>
          编程练习题 169</br>
          </blockquote>
      </details>
      <details>
      <summary>第25章　二叉查找树 171</summary>
          <blockquote>
          25.1　引言 171</br>
          <details>
          <summary>25.2　二叉查找树 171</summary>
              <blockquote>
              25.2.1　表示二叉查找树 172</br>
              25.2.2　查找一个元素 173</br>
              25.2.3　在BST中插入一个元素 173</br>
              25.2.4　树的遍历 174</br>
              25.2.5　BST类 176</br>
              </blockquote>
          </details>
          25.3　删除BST中的一个元素 184</br>
          25.4　树的可视化和MVC 189</br>
          25.5　迭代器 192</br>
          25.6　示例学习：数据压缩 194</br>
          关键术语 199</br>
          本章小结 199</br>
          测试题 199</br>
          编程练习题 199</br>
          </blockquote>
      </details>
      <details>
      <summary>第26章　AVL树 203</summary>
          <blockquote>
          26.1　引言 203</br>
          26.2　重新平衡树 204</br>
          26.3　为AVL树设计类 205</br>
          26.4　重写insert方法 207</br>
          26.5　实现旋转 207</br>
          26.6　实现delete方法 208</br>
          26.7　AVLTree类 209</br>
          26.8　测试 AVLTree类 214</br>
          26.9　AVL树的时间复杂度分析 216</br>
          关键术语 217</br>
          本章小结 217</br>
          测试题 217</br>
          编程练习题 217</br>
          </blockquote>
      </details>
      <details>
      <summary>第27章　散列 219</summary>
          <blockquote>
          27.1　引言 219</br>
          27.2　什么是散列 219</br>
          <details>
          <summary>27.3　散列函数和散列码 220</summary>
              <blockquote>
              27.3.1　基本数据类型的散列码 220</br>
              27.3.2　字符串类型的散列码 221</br>
              27.3.3　压缩散列码 221</br>
              </blockquote>
          </details>
          <details>
          <summary>27.4　使用开放地址法处理冲突 222</summary>
              <blockquote>
              27.4.1　线性探测 222</br>
              27.4.2　二次探测法 223</br>
              27.4.3　再哈希法 224</br>
              </blockquote>
          </details>
          27.5　使用链地址法处理冲突 225</br>
          27.6　装填因子和再散列 226</br>
          27.7　使用散列实现映射表 227</br>
          27.8　使用散列实现集合 235</br>
          关键术语 241</br>
          本章小结 242</br>
          测试题 242</br>
          编程练习题 242</br>
          </blockquote>
      </details>
      <details>
      <summary>第28章　图及其应用 244</summary>
          <blockquote>
          28.1　引言 244</br>
          28.2　基本的图术语 245</br>
          <details>
          <summary>28.3　表示图 247</summary>
              <blockquote>
              28.3.1　表示顶点 247</br>
              28.3.2　表示边：边数组 248</br>
              28.3.3　表示边：Edge对象 248</br>
              28.3.4　表示边：邻接矩阵 249</br>
              28.3.5　表示边：邻接线性表 249</br>
              </blockquote>
          </details>
          28.4　图建模 251</br>
          28.5　图的可视化 261</br>
          28.6　图的遍历 263</br>
          <details>
          <summary>28.7　深度优先搜索（DFS） 264</summary>
              <blockquote>
              28.7.1　DFS的算法 264</br>
              28.7.2　DFS的实现 265</br>
              28.7.3　DFS的应用 267</br>
              </blockquote>
          </details>
          28.8　示例学习：连通圆问题 268</br>
          <details>
          <summary>28.9　广度优先搜索（BFS） 270</summary>
              <blockquote>
              28.9.1　BFS的算法 270</br>
              28.9.2　BFS的实现 271</br>
              28.9.3　BFS的应用 272</br>
              </blockquote>
          </details>
          28.10　示例学习：9枚硬币反面问题 273</br>
          关键术语 278</br>
          本章小结 278</br>
          测试题 278</br>
          编程练习题 278</br>
          </blockquote>
      </details>
      <details>
      <summary>第29章　加权图及其应用 283</summary>
          <blockquote>
          29.1　引言 283</br>
          <details>
          <summary>29.2　加权图的表示 284</summary>
              <blockquote>
              29.2.1　加权边的表示：边数组 284</br>
              29.2.2　加权邻接矩阵 285</br>
              29.2.3　邻接线性表 285</br>
              </blockquote>
          </details>
          29.3　WeightedGraph类 286</br>
          <details>
          <summary>29.4　最小生成树 292</summary>
              <blockquote>
              29.4.1　最小生成树算法 293</br>
              29.4.2　完善Prim的MST算法 295</br>
              29.4.3　MST算法的实现 295</br>
              </blockquote>
          </details>
          29.5　寻找最短路径 298</br>
          29.6　示例学习：加权的9枚硬币反面问题 305</br>
          关键术语 308</br>
          本章小结 308</br>
          测试题 309</br>
          编程练习题 309</br>
          </blockquote>
      </details>
      <details>
      <summary>第30章　多线程和并行程序设计 314</summary>
          <blockquote>
          30.1　引言 314</br>
          30.2　线程的概念 314</br>
          30.3　创建任务和线程 315</br>
          30.4　Thread类 318</br>
          30.5　示例学习：闪烁的文本 320</br>
          30.6　线程池 322</br>
          <details>
          <summary>30.7　线程同步 324</summary>
              <blockquote>
              30.7.1　synchronized关键字 326</br>
              30.7.2　同步语句 327</br>
              </blockquote>
          </details>
          30.8　利用加锁同步 327</br>
          30.9　线程间协作 329</br>
          30.10　示例学习：生产者/消费者 333</br>
          30.11　阻塞队列 336</br>
          30.12　信号量 338</br>
          30.13　避免死锁 339</br>
          30.14　线程状态 340</br>
          30.15　同步合集 341</br>
          30.16　并行编程 342</br>
          关键术语 346</br>
          本章小结 346</br>
          测试题 347</br>
          编程练习题 347</br>
          </blockquote>
      </details>
      <details>
      <summary>第31章　网络 350</summary>
          <blockquote>
          31.1　引言 350</br>
          <details>
          <summary>31.2　客户端/服务器计算 351</summary>
              <blockquote>
              31.2.1　服务器套接字 351</br>
              31.2.2　客户端套接字 351</br>
              31.2.3　通过套接字进行数据传输 352</br>
              31.2.4　客户端/服务器示例 353</br>
              </blockquote>
          </details>
          31.3　InetAddress类 357</br>
          31.4　服务多个客户 358</br>
          31.5　发送和接收对象 361</br>
          31.6　示例学习：分布式井字游戏 365</br>
          关键术语 376</br>
          本章小结 376</br>
          测试题 376</br>
          编程练习题 376</br>
          </blockquote>
      </details>
      <details>
      <summary>第32章　Java数据库程序设计 379</summary>
          <blockquote>
          32.1　引言 379</br>
          <details>
          <summary>32.2　关系型数据库系统 379</summary>
              <blockquote>
              32.2.1　关系结构 380</br>
              32.2.2　完整性约束 381</br>
              </blockquote>
          </details>
          <details>
          <summary>32.3　SQL 383</summary>
              <blockquote>
              32.3.1　在MySQL上创建用户账户 383</br>
              32.3.2　创建数据库 384</br>
              32.3.3　创建和删除表 385</br>
              32.3.4　简单插入、更新和删除 386</br>
              32.3.5　简单查询 387</br>
              32.3.6　比较运算符和布尔运算符 387</br>
              32.3.7　操作符like、between-and和is null 388</br>
              32.3.8　列的别名 388</br>
              32.3.9　算术运算符 389</br>
              32.3.10　显示互不相同的记录 389</br>
              32.3.11　显示排好序的记录 390</br>
              32.3.12　联结表 390</br>
              </blockquote>
          </details>
          <details>
          <summary>32.4　JDBC 391</summary>
              <blockquote>
              32.4.1　使用JDBC开发数据库应用程序 392</br>
              32.4.2　从JavaFX访问数据库 396</br>
              </blockquote>
          </details>
          32.5　PreparedStatement 398</br>
          32.6　CallableStatement 400</br>
          <details>
          <summary>32.7　获取元数据 403</summary>
              <blockquote>
              32.7.1　数据库元数据 403</br>
              32.7.2　获取数据库表 404</br>
              32.7.3　结果集元数据 405</br>
              </blockquote>
          </details>
          关键术语 406</br>
          本章小结 406</br>
          测试题 407</br>
          编程练习题 407</br>
          </blockquote>
      </details>
      <details>
      <summary>第33章　JavaServer Faces 411</summary>
          <blockquote>
          33.1　引言 411</br>
          <details>
          <summary>33.2　开始使用JSF 411</summary>
              <blockquote>
              33.2.1　创建一个JSF项目 412</br>
              33.2.2　一个基本的JSF页面 412</br>
              33.2.3　JSF的受管JavaBean 414</br>
              33.2.4　JSF表达式 416</br>
              </blockquote>
          </details>
          33.3　JSF GUI组件 418</br>
          33.4　处理表单 421</br>
          33.5　示例学习：计算器 425</br>
          33.6　会话跟踪 428</br>
          33.7　验证输入 430</br>
          33.8　将数据库与facelet绑定 434</br>
          33.9　打开一个新的JSF页面 439</br>
          关键术语 445</br>
          本章小结 445</br>
          测试题 445</br>
          编程练习题 446</br>
          </blockquote>
      </details>
      <details>
      <summary>附录A　Java关键字 451</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录B　ASCII字符集 452</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录C　操作符优先级表 453</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录D　Java修饰符 454</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录E　特殊浮点值 455</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录F　数系 456</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录G　位操作 460</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录H　正则表达式 461</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>附录I　 枚举类型 465</summary>
      </details>
      </blockquote>
  </details></li>
<li>《Java核心技术·卷 I（原书第10版）: 基础知识》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章　Java程序设计概述 1</summary>
          <blockquote>
          1.1　Java程序设计平台 1</br>
          <details>
          <summary>1.2　Java“白皮书”的关键术语 2</summary>
              <blockquote>
              1.2.1　简单性 2</br>
              1.2.2　面向对象 2</br>
              1.2.3　分布式 3</br>
              1.2.4　健壮性 3</br>
              1.2.5　安全性 3</br>
              1.2.6　体系结构中立 4</br>
              1.2.7　可移植性 4</br>
              1.2.8　解释型 5</br>
              1.2.9　高性能 5</br>
              1.2.10　多线程 5</br>
              1.2.11　动态性 5</br>
              </blockquote>
          </details>
          1.3　Java applet与Internet 6</br>
          1.4　Java发展简史 7</br>
          1.5　关于Java的常见误解 9</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章　Java程序设计环境 12</summary>
          <blockquote>
          <details>
          <summary>2.1　安装Java开发工具包 12</summary>
              <blockquote>
              2.1.1　下载JDK 12</br>
              2.1.2　设置JDK 13</br>
              2.1.3　安装库源文件和文档 15</br>
              </blockquote>
          </details>
          2.2　使用命令行工具 16</br>
          2.3　使用集成开发环境 18</br>
          2.4　运行图形化应用程序 21</br>
          2.5　构建并运行applet 23</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章　Java的基本程序设计结构 28</summary>
          <blockquote>
          3.1　一个简单的Java应用程序 28</br>
          3.2　注释 31</br>
          <details>
          <summary>3.3　数据类型 32</summary>
              <blockquote>
              3.3.1　整型 32</br>
              3.3.2　浮点类型 33</br>
              3.3.3　char类型 34</br>
              3.3.4　Unicode和char类型 35</br>
              3.3.5　boolean类型 35</br>
              </blockquote>
          </details>
          <details>
          <summary>3.4　变量 36</summary>
              <blockquote>
              3.4.1　变量初始化 37</br>
              3.4.2　常量 37</br>
              </blockquote>
          </details>
          <details>
          <summary>3.5　运算符 38</summary>
              <blockquote>
              3.5.1　数学函数与常量 39</br>
              3.5.2　数值类型之间的转换 40</br>
              3.5.3　强制类型转换 41</br>
              3.5.4　结合赋值和运算符 42</br>
              3.5.5　自增与自减运算符 42</br>
              3.5.6　关系和boolean运算符 42</br>
              3.5.7　位运算符 43</br>
              3.5.8　括号与运算符级别 44</br>
              3.5.9　枚举类型 45</br>
              </blockquote>
          </details>
          <details>
          <summary>3.6　字符串 45</summary>
              <blockquote>
              3.6.1　子串 45</br>
              3.6.2　拼接 46</br>
              3.6.3　不可变字符串 46</br>
              3.6.4　检测字符串是否相等 47</br>
              3.6.5　空串与Null串 48</br>
              3.6.6　码点与代码单元 49</br>
              3.6.7　String API 50</br>
              3.6.8　阅读联机API文档 52</br>
              3.6.9　构建字符串 54</br>
              </blockquote>
          </details>
          <details>
          <summary>3.7　输入输出 55</summary>
              <blockquote>
              3.7.1　读取输入 55</br>
              3.7.2　格式化输出 58</br>
              3.7.3　文件输入与输出 61</br>
              </blockquote>
          </details>
          <details>
          <summary>3.8　控制流程 63</summary>
              <blockquote>
              3.8.1　块作用域 63</br>
              3.8.2　条件语句 63</br>
              3.8.3　循环 66</br>
              3.8.4　确定循环 69</br>
              3.8.5　多重选择：switch语句 72</br>
              3.8.6　中断控制流程语句 74</br>
              </blockquote>
          </details>
          3.9　大数值 76</br>
          <details>
          <summary>3.10　数组 78</summary>
              <blockquote>
              3.10.1　for each循环 79</br>
              3.10.2　数组初始化以及匿名数组 80</br>
              3.10.3　数组拷贝 81</br>
              3.10.4　命令行参数 81</br>
              3.10.5　数组排序 82</br>
              3.10.6　多维数组 85</br>
              3.10.7　不规则数组 88</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第4章　对象与类 91</summary>
          <blockquote>
          <details>
          <summary>4.1　面向对象程序设计概述 91</summary>
              <blockquote>
              4.1.1　类 92</br>
              4.1.2　对象 93</br>
              4.1.3　识别类 93</br>
              4.1.4　类之间的关系 94</br>
              </blockquote>
          </details>
          <details>
          <summary>4.2　使用预定义类 95</summary>
              <blockquote>
              4.2.1　对象与对象变量 95</br>
              4.2.2　Java类库中的LocalDate类 98</br>
              4.2.3　更改器方法与访问器方法 100</br>
              </blockquote>
          </details>
          <details>
          <summary>4.3　用户自定义类 103</summary>
              <blockquote>
              4.3.1　Employee类 103</br>
              4.3.2　多个源文件的使用 105</br>
              4.3.3　剖析Employee类 106</br>
              4.3.4　从构造器开始 106</br>
              4.3.5　隐式参数与显式参数 108</br>
              4.3.6　封装的优点 109</br>
              4.3.7　基于类的访问权限 111</br>
              4.3.8　私有方法 111</br>
              4.3.9　final实例域 112</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4　静态域与静态方法 112</summary>
              <blockquote>
              4.4.1　静态域 112</br>
              4.4.2　静态常量 113</br>
              4.4.3　静态方法 114</br>
              4.4.4　工厂方法 115</br>
              4.4.5　main方法 115</br>
              </blockquote>
          </details>
          4.5　方法参数 118</br>
          <details>
          <summary>4.6　对象构造 123</summary>
              <blockquote>
              4.6.1　重载 123</br>
              4.6.2　默认域初始化 123</br>
              4.6.3　无参数的构造器 124</br>
              4.6.4　显式域初始化 125</br>
              4.6.5　参数名 125</br>
              4.6.6　调用另一个构造器 126</br>
              4.6.7　初始化块 127</br>
              4.6.8　对象析构与finalize方法 130</br>
              </blockquote>
          </details>
          <details>
          <summary>4.7　包 131</summary>
              <blockquote>
              4.7.1　类的导入 131</br>
              4.7.2　静态导入 133</br>
              4.7.3　将类放入包中 133</br>
              4.7.4　包作用域 136</br>
              </blockquote>
          </details>
          <details>
          <summary>4.8　类路径 137</summary>
              <blockquote>
              4.8.1　设置类路径 139</br>
              </blockquote>
          </details>
          <details>
          <summary>4.9　文档注释 140</summary>
              <blockquote>
              4.9.1　注释的插入 140</br>
              4.9.2　类注释 140</br>
              4.9.3　方法注释 141</br>
              4.9.4　域注释 142</br>
              4.9.5　通用注释 142</br>
              4.9.6　包与概述注释 143</br>
              4.9.7　注释的抽取 143</br>
              </blockquote>
          </details>
          4.10　类设计技巧 144</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章　继承 147</summary>
          <blockquote>
          <details>
          <summary>5.1　类、超类和子类 147</summary>
              <blockquote>
              5.1.1　定义子类 147</br>
              5.1.2　覆盖方法 149</br>
              5.1.3　子类构造器 150</br>
              5.1.4　继承层次 153</br>
              5.1.5　多态 154</br>
              5.1.6　理解方法调用 155</br>
              5.1.7　阻止继承：final类和方法 157</br>
              5.1.8　强制类型转换 158</br>
              5.1.9　抽象类 160</br>
              5.1.10　受保护访问 165</br>
              </blockquote>
          </details>
          <details>
          <summary>5.2　Object：所有类的超类 166</summary>
              <blockquote>
              5.2.1　equals方法 166</br>
              5.2.2　相等测试与继承 167</br>
              5.2.3　hashCode方法 170</br>
              5.2.4　toString方法 172</br>
              </blockquote>
          </details>
          <details>
          <summary>5.3　泛型数组列表 178</summary>
              <blockquote>
              5.3.1　访问数组列表元素 180</br>
              5.3.2　类型化与原始数组列表的兼容性 183</br>
              </blockquote>
          </details>
          5.4　对象包装器与自动装箱 184</br>
          5.5　参数数量可变的方法 187</br>
          5.6　枚举类 188</br>
          <details>
          <summary>5.7　反射 190</summary>
              <blockquote>
              5.7.1　Class类 190</br>
              5.7.2　捕获异常 192</br>
              5.7.3　利用反射分析类的能力 194</br>
              5.7.4　在运行时使用反射分析对象 198</br>
              5.7.5　使用反射编写泛型数组代码 202</br>
              5.7.6　调用任意方法 205</br>
              </blockquote>
          </details>
          5.8　继承的设计技巧 208</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章　接口、lambda表达式与内部类 211</summary>
          <blockquote>
          <details>
          <summary>6.1　接口 211</summary>
              <blockquote>
              6.1.1　接口概念 211</br>
              6.1.2　接口的特性 217</br>
              6.1.3　接口与抽象类 218</br>
              6.1.4　静态方法 218</br>
              6.1.5　默认方法 219</br>
              6.1.6　解决默认方法冲突 220</br>
              </blockquote>
          </details>
          <details>
          <summary>6.2　接口示例 222</summary>
              <blockquote>
              6.2.1　接口与回调 222</br>
              6.2.2　Comparator接口 224</br>
              6.2.3　对象克隆 225</br>
              </blockquote>
          </details>
          <details>
          <summary>6.3　lambda表达式 231</summary>
              <blockquote>
              6.3.1　为什么引入lambda表达式 231</br>
              6.3.2　lambda表达式的语法 232</br>
              6.3.3　函数式接口 234</br>
              6.3.4　方法引用 235</br>
              6.3.5　构造器引用 237</br>
              6.3.6　变量作用域 237</br>
              6.3.7　处理lambda表达式 239</br>
              6.3.8　再谈Comparator 242</br>
              </blockquote>
          </details>
          <details>
          <summary>6.4　内部类 242</summary>
              <blockquote>
              6.4.1　使用内部类访问对象状态 244</br>
              6.4.2　内部类的特殊语法规则 247</br>
              6.4.3　内部类是否有用、必要和安全 248</br>
              6.4.4　局部内部类 250</br>
              6.4.5　由外部方法访问变量 250</br>
              6.4.6　匿名内部类 252</br>
              6.4.7　静态内部类 255</br>
              </blockquote>
          </details>
          <details>
          <summary>6.5　代理 258</summary>
              <blockquote>
              6.5.1　何时使用代理 259</br>
              6.5.2　创建代理对象 259</br>
              6.5.3　代理类的特性 262</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第7章　异常、断言和日志 264</summary>
          <blockquote>
          <details>
          <summary>7.1　处理错误 264</summary>
              <blockquote>
              7.1.1　异常分类 265</br>
              7.1.2　声明受查异常 267</br>
              7.1.3　如何抛出异常 269</br>
              7.1.4　创建异常类 270</br>
              </blockquote>
          </details>
          <details>
          <summary>7.2　捕获异常 271</summary>
              <blockquote>
              7.2.1　捕获异常 271</br>
              7.2.2　捕获多个异常 273</br>
              7.2.3　再次抛出异常与异常链 274</br>
              7.2.4　finally子句 275</br>
              7.2.5　带资源的try语句 278</br>
              7.2.6　分析堆栈轨迹元素 280</br>
              </blockquote>
          </details>
          7.3　使用异常机制的技巧 282</br>
          <details>
          <summary>7.4　使用断言 285</summary>
              <blockquote>
              7.4.1　断言的概念 285</br>
              7.4.2　启用和禁用断言 286</br>
              7.4.3　使用断言完成参数检查 287</br>
              7.4.4　为文档假设使用断言 288</br>
              </blockquote>
          </details>
          <details>
          <summary>7.5　记录日志 289</summary>
              <blockquote>
              7.5.1　基本日志 289</br>
              7.5.2　高级日志 289</br>
              7.5.3　修改日志管理器配置 291</br>
              7.5.4　本地化 292</br>
              7.5.5　处理器 293</br>
              7.5.6　过滤器 296</br>
              7.5.7　格式化器 296</br>
              7.5.8　日志记录说明 296</br>
              </blockquote>
          </details>
          7.6　调试技巧 304</br>
          </blockquote>
      </details>
      <details>
      <summary>第8章　泛型程序设计 309</summary>
          <blockquote>
          <details>
          <summary>8.1　为什么要使用泛型程序设计 309</summary>
              <blockquote>
              8.1.1　类型参数的好处 309</br>
              8.1.2　谁想成为泛型程序员 310</br>
              </blockquote>
          </details>
          8.2　定义简单泛型类 311</br>
          8.3　泛型方法 313</br>
          8.4　类型变量的限定 314</br>
          <details>
          <summary>8.5　泛型代码和虚拟机 316</summary>
              <blockquote>
              8.5.1　类型擦除 316</br>
              8.5.2　翻译泛型表达式 317</br>
              8.5.3　翻译泛型方法 318</br>
              8.5.4　调用遗留代码 319</br>
              </blockquote>
          </details>
          <details>
          <summary>8.6　约束与局限性 320</summary>
              <blockquote>
              8.6.1　不能用基本类型实例化类型参数 320</br>
              8.6.2　运行时类型查询只适用于原始类型 321</br>
              8.6.3　不能创建参数化类型的数组 321</br>
              8.6.4　Varargs警告 322</br>
              8.6.5　不能实例化类型变量 323</br>
              8.6.6　不能构造泛型数组 323</br>
              8.6.7　泛型类的静态上下文中类型变量无效 325</br>
              8.6.8　不能抛出或捕获泛型类的实例 325</br>
              8.6.9　可以消除对受查异常的检查 326</br>
              8.6.10　注意擦除后的冲突 327</br>
              </blockquote>
          </details>
          8.7　泛型类型的继承规则 328</br>
          <details>
          <summary>8.8　通配符类型 330</summary>
              <blockquote>
              8.8.1　通配符概念 330</br>
              8.8.2　通配符的超类型限定 331</br>
              8.8.3　无限定通配符 334</br>
              8.8.4　通配符捕获 334</br>
              </blockquote>
          </details>
          <details>
          <summary>8.9　反射和泛型 337</summary>
              <blockquote>
              8.9.1　泛型Class类 337</br>
              8.9.2　使用Class参数进行类型匹配 338</br>
              8.9.3　虚拟机中的泛型类型信息 338</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第9章　集合 344</summary>
          <blockquote>
          <details>
          <summary>9.1　Java集合框架 344</summary>
              <blockquote>
              9.1.1　将集合的接口与实现分离 344</br>
              9.1.2　Collection接口 346</br>
              9.1.3　迭代器 347</br>
              9.1.4　泛型实用方法 349</br>
              9.1.5　集合框架中的接口 352</br>
              </blockquote>
          </details>
          <details>
          <summary>9.2　具体的集合 353</summary>
              <blockquote>
              9.2.1　链表 355</br>
              9.2.2　数组列表 362</br>
              9.2.3　散列集 363</br>
              9.2.4　树集 366</br>
              9.2.5　队列与双端队列 369</br>
              9.2.6　优先级队列 371</br>
              </blockquote>
          </details>
          <details>
          <summary>9.3　映射 372</summary>
              <blockquote>
              9.3.1　基本映射操作 372</br>
              9.3.2　更新映射项 375</br>
              9.3.3　映射视图 376</br>
              9.3.4　弱散列映射 377</br>
              9.3.5　链接散列集与映射 378</br>
              9.3.6　枚举集与映射 379</br>
              9.3.7　标识散列映射 380</br>
              </blockquote>
          </details>
          <details>
          <summary>9.4　视图与包装器 381</summary>
              <blockquote>
              9.4.1　轻量级集合包装器 382</br>
              9.4.2　子范围 382</br>
              9.4.3　不可修改的视图 383</br>
              9.4.4　同步视图 384</br>
              9.4.5　受查视图 384</br>
              9.4.6　关于可选操作的说明 385</br>
              </blockquote>
          </details>
          <details>
          <summary>9.5　算法 388</summary>
              <blockquote>
              9.5.1　排序与混排 389</br>
              9.5.2　二分查找 391</br>
              9.5.3　简单算法 392</br>
              9.5.4　批操作 394</br>
              9.5.5　集合与数组的转换 394</br>
              9.5.6　编写自己的算法 395</br>
              </blockquote>
          </details>
          <details>
          <summary>9.6　遗留的集合 396</summary>
              <blockquote>
              9.6.1　Hashtable类 397</br>
              9.6.2　枚举 397</br>
              9.6.3　属性映射 398</br>
              9.6.4　栈 399</br>
              9.6.5　位集 399</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第10章　图形程序设计 403</summary>
          <blockquote>
          10.1　Swing概述 403</br>
          10.2　创建框架 407</br>
          <details>
          <summary>10.3　框架定位 409</summary>
              <blockquote>
              10.3.1　框架属性 411</br>
              10.3.2　确定合适的框架大小 411</br>
              </blockquote>
          </details>
          10.4　在组件中显示信息 415</br>
          10.5　处理2D图形 419</br>
          10.6　使用颜色 426</br>
          10.7　文本使用特殊字体 429</br>
          10.8　显示图像 435</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章　事件处理 439</summary>
          <blockquote>
          <details>
          <summary>11.1　事件处理基础 439</summary>
              <blockquote>
              11.1.1　实例：处理按钮点击事件 441</br>
              11.1.2　简洁地指定监听器 445</br>
              11.1.3　实例：改变观感 447</br>
              11.1.4　适配器类 450</br>
              </blockquote>
          </details>
          11.2　动作 453</br>
          11.3　鼠标事件 459</br>
          <details>
          <summary>11.4　AWT事件继承层次 465</summary>
              <blockquote>
              11.4.1　语义事件和底层事件 466</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第12章　Swing用户界面组件 469</summary>
          <blockquote>
          <details>
          <summary>12.1　Swing和模型–视图–控制器设计模式 469</summary>
              <blockquote>
              12.1.1　设计模式 469</br>
              12.1.2　模型–视图–控制器模式 470</br>
              12.1.3　Swing按钮的模型–视图–控制器分析 473</br>
              </blockquote>
          </details>
          <details>
          <summary>12.2　布局管理概述 474</summary>
              <blockquote>
              12.2.1　边框布局 477</br>
              12.2.2　网格布局 478</br>
              </blockquote>
          </details>
          <details>
          <summary>12.3　文本输入 481</summary>
              <blockquote>
              12.3.1　文本域 482</br>
              12.3.2　标签和标签组件 483</br>
              12.3.3　密码域 484</br>
              12.3.4　文本区 485</br>
              12.3.5　滚动窗格 485</br>
              </blockquote>
          </details>
          <details>
          <summary>12.4　选择组件 488</summary>
              <blockquote>
              12.4.1　复选框 488</br>
              12.4.2　单选钮 490</br>
              12.4.3　边框 493</br>
              12.4.4　组合框 496</br>
              12.4.5　滑动条 499</br>
              </blockquote>
          </details>
          <details>
          <summary>12.5　菜单 504</summary>
              <blockquote>
              12.5.1　菜单创建 504</br>
              12.5.2　菜单项中的图标 507</br>
              12.5.3　复选框和单选钮菜单项 508</br>
              12.5.4　弹出菜单 508</br>
              12.5.5　快捷键和加速器 510</br>
              12.5.6　启用和禁用菜单项 511</br>
              12.5.7　工具栏 515</br>
              12.5.8　工具提示 516</br>
              </blockquote>
          </details>
          <details>
          <summary>12.6　复杂的布局管理 518</summary>
              <blockquote>
              12.6.1　网格组布局 520</br>
              12.6.2　组布局 528</br>
              12.6.3　不使用布局管理器 537</br>
              12.6.4　定制布局管理器 537</br>
              12.6.5　遍历顺序 541</br>
              </blockquote>
          </details>
          <details>
          <summary>12.7　对话框 541</summary>
              <blockquote>
              12.7.1　选项对话框 542</br>
              12.7.2　创建对话框 551</br>
              12.7.3　数据交换 554</br>
              12.7.4　文件对话框 559</br>
              12.7.5　颜色选择器 569</br>
              </blockquote>
          </details>
          <details>
          <summary>12.8　GUI程序排错 573</summary>
              <blockquote>
              12.8.1　调试技巧 573</br>
              12.8.2　让AWT机器人完成工作 576</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第13章　部署Java应用程序 580</summary>
          <blockquote>
          <details>
          <summary>13.1　JAR文件 580</summary>
              <blockquote>
              13.1.1　创建JAR文件 580</br>
              13.1.2　清单文件 581</br>
              13.1.3　可执行JAR文件 582</br>
              13.1.4　资源 583</br>
              13.1.5　密封 585</br>
              </blockquote>
          </details>
          <details>
          <summary>13.2　应用首选项的存储 586</summary>
              <blockquote>
              13.2.1　属性映射 586</br>
              13.2.2　首选项API 591</br>
              </blockquote>
          </details>
          13.3　服务加载器 596</br>
          <details>
          <summary>13.4　applet 598</summary>
              <blockquote>
              13.4.1　一个简单的applet 599</br>
              13.4.2　applet HTML标记和属性 602</br>
              13.4.3　使用参数向applet传递信息 603</br>
              13.4.4　访问图像和音频文件 608</br>
              13.4.5　applet上下文 609</br>
              13.4.6　applet间通信 609</br>
              13.4.7　在浏览器中显示信息项 610</br>
              13.4.8　沙箱 611</br>
              13.4.9　签名代码 612</br>
              </blockquote>
          </details>
          <details>
          <summary>13.5　Java Web Start 614</summary>
              <blockquote>
              13.5.1　发布Java Web Start应用 614</br>
              13.5.2　JNLP API 617</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第14章　并发 624</summary>
          <blockquote>
          <details>
          <summary>14.1　什么是线程 624</summary>
              <blockquote>
              14.1.1　使用线程给其他任务提供机会 629</br>
              </blockquote>
          </details>
          14.2　中断线程 632</br>
          <details>
          <summary>14.3　线程状态 635</summary>
              <blockquote>
              14.3.1　新创建线程 635</br>
              14.3.2　可运行线程 635</br>
              14.3.3　被阻塞线程和等待线程 636</br>
              14.3.4　被终止的线程 636</br>
              </blockquote>
          </details>
          <details>
          <summary>14.4　线程属性 638</summary>
              <blockquote>
              14.4.1　线程优先级 638</br>
              14.4.2　守护线程 639</br>
              14.4.3　未捕获异常处理器 639</br>
              </blockquote>
          </details>
          <details>
          <summary>14.5　同步 640</summary>
              <blockquote>
              14.5.1　竞争条件的一个例子 641</br>
              14.5.2　竞争条件详解 644</br>
              14.5.3　锁对象 646</br>
              14.5.4　条件对象 648</br>
              14.5.5　synchronized关键字 653</br>
              14.5.6　同步阻塞 656</br>
              14.5.7　监视器概念 657</br>
              14.5.8　Volatile域 658</br>
              14.5.9　final变量 659</br>
              14.5.10　原子性 659</br>
              14.5.11　死锁 661</br>
              14.5.12　线程局部变量 663</br>
              14.5.13　锁测试与超时 665</br>
              14.5.14　读/写锁 666</br>
              14.5.15　为什么弃用stop和suspend方法 667</br>
              </blockquote>
          </details>
          14.6　阻塞队列 668</br>
          <details>
          <summary>14.7　线程安全的集合 673</summary>
              <blockquote>
              14.7.1　高效的映射、集和队列 674</br>
              14.7.2　映射条目的原子更新 675</br>
              14.7.3　对并发散列映射的批操作 676</br>
              14.7.4　并发集视图 678</br>
              14.7.5　写数组的拷贝 679</br>
              14.7.6　并行数组算法 679</br>
              14.7.7　较早的线程安全集合 680</br>
              </blockquote>
          </details>
          14.8　Callable与Future 681</br>
          <details>
          <summary>14.9　执行器 685</summary>
              <blockquote>
              14.9.1　线程池 685</br>
              14.9.2　预定执行 689</br>
              14.9.3　控制任务组 690</br>
              14.9.4　Fork-Join框架 691</br>
              14.9.5　可完成Future 694</br>
              </blockquote>
          </details>
          <details>
          <summary>14.10　同步器 696</summary>
              <blockquote>
              14.10.1　信号量 696</br>
              14.10.2　倒计时门栓 697</br>
              14.10.3　障栅 697</br>
              14.10.4　交换器 698</br>
              14.10.5　同步队列 698</br>
              </blockquote>
          </details>
          <details>
          <summary>14.11　线程与Swing 698</summary>
              <blockquote>
              14.11.1　运行耗时的任务 699</br>
              14.11.2　使用Swing工作线程 703</br>
              14.11.3　单一线程规则 708</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      附录A　Java关键字 710</br>
      </blockquote>
  </details></li>
<li>《Java核心技术·卷 II（原书第10版）: 高级特性》  <details>
  <summary>目录(第九版)</summary>
      <blockquote>
      <details>
      <summary>第1章　流与文件 1</summary>
          <blockquote>
          <details>
          <summary>1.1　流 1</summary>
              <blockquote>
              1.1.1　读写字节 1</br>
              1.1.2　完整的流家族 3</br>
              1.1.3　组合流过滤器 7</br>
              </blockquote>
          </details>
          <details>
          <summary>1.2　文本输入与输出 10</summary>
              <blockquote>
              1.2.1　如何写出文本输出 10</br>
              1.2.2　如何读入文本输入 13</br>
              1.2.3　以文本格式存储对象 13</br>
              1.2.4　字符集 16</br>
              </blockquote>
          </details>
          1.3　读写二进制数据 20</br>
          1.4　ZIP文档 27</br>
          <details>
          <summary>1.5　对象流与序列化 29</summary>
              <blockquote>
              1.5.1　理解对象序列化的文件格式 34</br>
              1.5.2　修改默认的序列化机制 39</br>
              1.5.3　序列化单例和类型安全的枚举 40</br>
              1.5.4　版本管理 42</br>
              1.5.5　为克隆使用序列化 44</br>
              </blockquote>
          </details>
          <details>
          <summary>1.6　操作文件 46</summary>
              <blockquote>
              1.6.1　Path 46</br>
              1.6.2　读写文件 48</br>
              1.6.3　复制、移动和删除文件 49</br>
              1.6.4　创建文件和目录 50</br>
              1.6.5　获取文件信息 51</br>
              1.6.6　迭代目录中的文件 53</br>
              1.6.7　ZIP文件系统 55</br>
              </blockquote>
          </details>
          <details>
          <summary>1.7　内存映射文件 56</summary>
              <blockquote>
              1.7.1　缓冲区数据结构 62</br>
              1.7.2　文件加锁机制 64</br>
              </blockquote>
          </details>
          1.8　正则表达式 66</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章　XML 76</summary>
          <blockquote>
          2.1　XML概述 76</br>
          2.2　解析XML文档 81</br>
          <details>
          <summary>2.3　验证XML文档 91</summary>
              <blockquote>
              2.3.1　文档类型定义 92</br>
              2.3.2　XML Schema 98</br>
              2.3.3　实用示例 101</br>
              </blockquote>
          </details>
          2.4　使用XPath来定位信息 113</br>
          2.5　使用命名空间 119</br>
          <details>
          <summary>2.6　流机制解析器 121</summary>
              <blockquote>
              2.6.1　使用SAX解析器 122</br>
              2.6.2　使用StAX解析器 126</br>
              </blockquote>
          </details>
          <details>
          <summary>2.7　生成XML文档 129</summary>
              <blockquote>
              2.7.1　不带命名空间的文档 130</br>
              2.7.2　带命名空间的文档 130</br>
              2.7.3　写出文档 131</br>
              2.7.4　示例：生成SVG文件 131</br>
              2.7.5　使用StAX写XML文档 133</br>
              </blockquote>
          </details>
          2.8　XSL转换 140</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章　网络 151</summary>
          <blockquote>
          <details>
          <summary>3.1　连接到服务器 151</summary>
              <blockquote>
              3.1.1　套接字超时 155</br>
              3.1.2　因特网地址 156</br>
              </blockquote>
          </details>
          <details>
          <summary>3.2　实现服务器 157</summary>
              <blockquote>
              3.2.1　为多个客户端服务 160</br>
              3.2.2　半关闭 163</br>
              </blockquote>
          </details>
          3.3　可中断套接字 164</br>
          <details>
          <summary>3.4　获取Web数 171</summary>
              <blockquote>
              3.4.1　URL和URI 171</br>
              3.4.2　使用URLConnection获取信息 173</br>
              3.4.3　提交表单数据 181</br>
              </blockquote>
          </details>
          3.5　发送E-mail 187</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章　数据库编程 191</summary>
          <blockquote>
          <details>
          <summary>4.1　JDBC的设计 191</summary>
              <blockquote>
              4.1.1　JDBC驱动程序类型 192</br>
              4.1.2　JDBC的典型用法 193</br>
              </blockquote>
          </details>
          4.2　结构化查询语言 194</br>
          <details>
          <summary>4.3　JDBC配置 198</summary>
              <blockquote>
              4.3.1　数据库URL 199</br>
              4.3.2　驱动程序JAR文件 199</br>
              4.3.3　启动数据库 199</br>
              4.3.4　注册驱动器类 200</br>
              4.3.5　连接到数据库 201</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4　执行SQL语句 203</summary>
              <blockquote>
              4.4.1　管理连接、语句和结果集 206</br>
              4.4.2　分析SQL异常 207</br>
              4.4.3　组装数据库 209</br>
              </blockquote>
          </details>
          <details>
          <summary>4.5　执行查询操作 212</summary>
              <blockquote>
              4.5.1　预备语句 212</br>
              4.5.2　读写LOB 218</br>
              4.5.3　SQL转义 219</br>
              4.5.4　多结果集 220</br>
              4.5.5　获取自动生成键 221</br>
              </blockquote>
          </details>
          <details>
          <summary>4.6　可滚动和可更新的结果集 222</summary>
              <blockquote>
              4.6.1　可滚动的结果集 222</br>
              4.6.2　可更新的结果集 224</br>
              </blockquote>
          </details>
          <details>
          <summary>4.7　行集 228</summary>
              <blockquote>
              4.7.1　构建行集 228</br>
              4.7.2　被缓存的行集 229</br>
              </blockquote>
          </details>
          4.8　元数据 231</br>
          <details>
          <summary>4.9　事务 240</summary>
              <blockquote>
              4.9.1　保存点 241</br>
              4.9.2　批量更新 241</br>
              4.9.3　高级SQL类型 243</br>
              </blockquote>
          </details>
          4.10　Web与企业应用中的连接管理 244</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章　国际化 246</summary>
          <blockquote>
          5.1　Locales 246</br>
          5.2　数字格式 251</br>
          5.3　日期和时间 257</br>
          <details>
          <summary>5.4　排序 264</summary>
              <blockquote>
              5.4.1　排序强度 265</br>
              5.4.2　分解 265</br>
              </blockquote>
          </details>
          5.5　消息格式化 270</br>
          选择格式 272</br>
          5.6　文本文件和字符集 273</br>
          源文件的字符编码 274</br>
          <details>
          <summary>5.7　资源包 275</summary>
              <blockquote>
              5.7.1　定位资源包 275</br>
              5.7.2　属性文件 276</br>
              5.7.3　包类 277</br>
              </blockquote>
          </details>
          5.8　一个完整的例子 278</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章　高级Swing 293</summary>
          <blockquote>
          <details>
          <summary>6.1　列表 293</summary>
              <blockquote>
              6.1.1　JList构件 293</br>
              6.1.2　列表模式 298</br>
              6.1.3　插入和移除值 302</br>
              6.1.4　值的绘制 304</br>
              </blockquote>
          </details>
          <details>
          <summary>6.2　表格 307</summary>
              <blockquote>
              6.2.1　简单表格 307</br>
              6.2.2　表格模型 310</br>
              6.2.3　对行和列的操作 314</br>
              6.2.4　单元格的绘制和编辑 328</br>
              </blockquote>
          </details>
          <details>
          <summary>6.3　树 338</summary>
              <blockquote>
              6.3.1　简单的树 339</br>
              6.3.2　节点枚举 352</br>
              6.3.3　绘制节点 353</br>
              6.3.4　监听树事件 356</br>
              6.3.5　定制树模型 362</br>
              </blockquote>
          </details>
          <details>
          <summary>6.4　文本构件 370</summary>
              <blockquote>
              6.4.1　文本构件中的修改跟踪 371</br>
              6.4.2　格式化的输入框 373</br>
              6.4.3　JSpinner构件 388</br>
              6.4.4　用JEditorPane显示HTML 395</br>
              </blockquote>
          </details>
          <details>
          <summary>6.5　进度指示器 401</summary>
              <blockquote>
              6.5.1　进度条 401</br>
              6.5.2　进度监视器 404</br>
              6.5.3　监视输入流的进度 407</br>
              </blockquote>
          </details>
          <details>
          <summary>6.6　构件组织器和装饰器 411</summary>
              <blockquote>
              6.6.1　分割面板 411</br>
              6.6.2　选项卡面板 414</br>
              6.6.3　桌面面板和内部框体 419</br>
              6.6.4　级联与平铺 422</br>
              6.6.5　否决属性设置 425</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第7章　高级AWT 440</summary>
          <blockquote>
          7.1　绘图操作流程 440</br>
          7.2　形状 442</br>
          7.3　区域 456</br>
          7.4　笔划 458</br>
          7.5　着色 465</br>
          7.6　坐标变换 466</br>
          7.7　剪切 471</br>
          7.8　透明与组合 473</br>
          7.9　绘图提示 481</br>
          <details>
          <summary>7.10　图像的读取器和写入器 486</summary>
              <blockquote>
              7.10.1　获得图像文件类型的读取器和写入器 487</br>
              7.10.2　读取和写入带有多个图像的文件 488</br>
              </blockquote>
          </details>
          <details>
          <summary>7.11　图像处理 496</summary>
              <blockquote>
              7.11.1　构建光栅图像 496</br>
              7.11.2　图像过滤 502</br>
              </blockquote>
          </details>
          <details>
          <summary>7.12　打印 510</summary>
              <blockquote>
              7.12.1　图形打印 510</br>
              7.12.2　打印多页文件 518</br>
              7.12.3　打印预览 520</br>
              7.12.4　打印服务程序 528</br>
              7.12.5　流打印服务程序 531</br>
              7.12.6　打印属性 532</br>
              </blockquote>
          </details>
          <details>
          <summary>7.13　剪贴板 538</summary>
              <blockquote>
              7.13.1　用于数据传递的类和接口 539</br>
              7.13.2　传递文本 540</br>
              7.13.3　Transferable接口和数据风格 543</br>
              7.13.4　构建一个可传递的图像 545</br>
              7.13.5　通过系统剪贴板传递Java对象 548</br>
              7.13.6　使用本地剪贴板来传递对象引用 552</br>
              </blockquote>
          </details>
          <details>
          <summary>7.14　拖放操作 552</summary>
              <blockquote>
              7.14.1　Swing对数据传递的支持 553</br>
              7.14.2　拖曳源 557</br>
              7.14.3　放置目标 559</br>
              </blockquote>
          </details>
          <details>
          <summary>7.15　平台集成 566</summary>
              <blockquote>
              7.15.1　闪屏 566</br>
              7.15.2　启动桌面应用程序 571</br>
              7.15.3　系统托盘 576</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第8章　JavaBean构件 581</summary>
          <blockquote>
          8.1　为何使用Bean 581</br>
          8.2　编写Bean的过程 583</br>
          <details>
          <summary>8.3　使用Bean构造应用程序 585</summary>
              <blockquote>
              8.3.1　将Bean打包成JAR文件 585</br>
              8.3.2　在开发环境中组合Bean 586</br>
              </blockquote>
          </details>
          8.4　Bean属性与事件的命名模式 591</br>
          <details>
          <summary>8.5　Bean属性的类型 594</summary>
              <blockquote>
              8.5.1　简单属性 594</br>
              8.5.2　索引属性 594</br>
              8.5.3　绑定属性 595</br>
              8.5.4　约束属性 596</br>
              </blockquote>
          </details>
          8.6　BeanInfo类 603</br>
          8.7　属性编辑器 607</br>
          8.8　定制器 616</br>
          <details>
          <summary>8.9　JavaBean持久化 624</summary>
              <blockquote>
              8.9.1　JavaBean持久化可用于任何数据 628</br>
              8.9.2　一个JavaBean持久化的完整示例 633</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第9章　安全 644</summary>
          <blockquote>
          <details>
          <summary>9.1　类加载器 645</summary>
              <blockquote>
              9.1.1　类加载器的层次结构 646</br>
              9.1.2　将类加载器作为命名空间 647</br>
              9.1.3　编写你自己的类加载器 648</br>
              </blockquote>
          </details>
          9.2　字节码校验 653</br>
          <details>
          <summary>9.3　安全管理器与访问权限 657</summary>
              <blockquote>
              9.3.1　Java平台安全性 658</br>
              9.3.2　安全策略文件 661</br>
              9.3.3　定制权限 667</br>
              9.3.4　实现权限类 669</br>
              </blockquote>
          </details>
          9.4　用户认证 674</br>
          <details>
          <summary>9.5　数字签名 687</summary>
              <blockquote>
              9.5.1　消息摘要 688</br>
              9.5.2　消息签名 691</br>
              9.5.3　校验签名 693</br>
              9.5.4　认证问题 695</br>
              9.5.5　证书签名 697</br>
              9.5.6　证书请求 698</br>
              </blockquote>
          </details>
          <details>
          <summary>9.6　代码签名 699</summary>
              <blockquote>
              9.6.1　JAR文件签名 699</br>
              9.6.2　软件开发者证书 702</br>
              </blockquote>
          </details>
          <details>
          <summary>9.7　加密 704</summary>
              <blockquote>
              9.7.1　对称密码 705</br>
              9.7.2　密钥生成 706</br>
              9.7.3　密码流 710</br>
              9.7.4　公共密钥密码 711</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第10章　脚本、编译与注解处理 716</summary>
          <blockquote>
          <details>
          <summary>10.1　Java平台的脚本 716</summary>
              <blockquote>
              10.1.1　获取脚本引擎 716</br>
              10.1.2　脚本赋值与绑定 717</br>
              10.1.3　重定向输入和输出 719</br>
              10.1.4　调用脚本的函数和方法 720</br>
              10.1.5　编译脚本 722</br>
              10.1.6　一个示例：用脚本处理GUI事件 722</br>
              </blockquote>
          </details>
          <details>
          <summary>10.2　编译器API 727</summary>
              <blockquote>
              10.2.1　编译便捷之法 727</br>
              10.2.2　使用编译工具 727</br>
              10.2.3　一个示例：动态Java代码生成 732</br>
              </blockquote>
          </details>
          10.3　使用注解 737</br>
          10.4　注解语法 743</br>
          <details>
          <summary>10.5　标准注解 746</summary>
              <blockquote>
              10.5.1　用于编译的注解 747</br>
              10.5.2　用于管理资源的注解 748</br>
              10.5.3　元注解 748</br>
              </blockquote>
          </details>
          10.6　源码级注解处理 750</br>
          10.7　字节码工程 756</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章　分布式对象 765</summary>
          <blockquote>
          11.1　客户与服务器的角色 765</br>
          11.2　远程方法调用 767</br>
          <details>
          <summary>11.3　RMI编程模型 769</summary>
              <blockquote>
              11.3.1　接口与实现 769</br>
              11.3.2　RMI注册表 770</br>
              11.3.3　部署程序 774</br>
              11.3.4　记录RMI活动的日志 776</br>
              </blockquote>
          </details>
          <details>
          <summary>11.4　远程方法中的参数和返回值 778</summary>
              <blockquote>
              11.4.1　传递远程对象 778</br>
              11.4.2　传递非远程对象 779</br>
              11.4.3　动态类加载 781</br>
              11.4.4　具有多重接口的远程引用 785</br>
              11.4.5　远程对象与equals、hashCode和clone方法 786</br>
              </blockquote>
          </details>
          11.5　远程对象激活 786</br>
          </blockquote>
      </details>
      <details>
      <summary>第12章　本地方法 792</summary>
          <blockquote>
          12.1　从Java程序中调用C函数 793</br>
          12.2　数值参数与返回值 797</br>
          12.3　字符串参数 799</br>
          <details>
          <summary>12.4　访问域 804</summary>
              <blockquote>
              12.4.1　访问实例域 804</br>
              12.4.2　访问静态域 808</br>
              </blockquote>
          </details>
          12.5　编码签名 809</br>
          <details>
          <summary>12.6　调用Java方法 810</summary>
              <blockquote>
              12.6.1　实例方法 810</br>
              12.6.2　静态方法 813</br>
              12.6.3　构造器 814</br>
              12.6.4　替代方法调用 815</br>
              </blockquote>
          </details>
          12.7　访问数组元素 816</br>
          12.8　错误处理 820</br>
          12.9　使用调用API 824</br>
          <details>
          <summary>12.10　完整的示例：访问Windows注册表 829</summary>
              <blockquote>
              12.10.1　Windows注册表概述 829</br>
              12.10.2　访问注册表的Java平台接口 830</br>
              12.10.3　以本地方法方式实现注册表访问函数 830</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      </blockquote>
  </details></li>
<li>《深入理解Java虚拟机（第2版）: JVM高级特性与最佳实践》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第一部分　走近java</summary>
          <blockquote>
          <details>
          <summary>第1章　走近java</summary>
              <blockquote>
              1.1　概述</br>
              1.2　java技术体系</br>
              1.3　java发展史</br>
              <details>
              <summary>1.4　java虚拟机发展史</summary>
                  <blockquote>
                  1.4.1　sun classic exact vm</br>
                  1.4.2　sun hotspot vm</br>
                  1.4.3　sun mobile-embedded vm meta-circular vm</br>
                  1.4.4　bea jrockit ibm j9 vm</br>
                  1.4.5　azul vm bea liquid vm</br>
                  1.4.6　apache harmony google android dalvik vm</br>
                  1.4.7　microsoft jvm及其他</br>
                  </blockquote>
              </details>
              <details>
              <summary>1.5　展望java技术的未来</summary>
                  <blockquote>
                  1.5.1　模块化</br>
                  1.5.2　混合语言</br>
                  1.5.3　多核并行</br>
                  1.5.4　进一步丰富语法</br>
                  1.5.5　64位虚拟机</br>
                  </blockquote>
              </details>
              <details>
              <summary>1.6　实战：自己编译jdk</summary>
                  <blockquote>
                  1.6.1　获取jdk源码</br>
                  1.6.2　系统需求</br>
                  1.6.3　构建编译环境</br>
                  1.6.4　进行编译</br>
                  1.6.5　在ide工具中进行源码调试</br>
                  </blockquote>
              </details>
              1.7　本章小结</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第二部分　自动内存管理机制</summary>
          <blockquote>
          <details>
          <summary>第2章　java内存区域与内存溢出异常</summary>
              <blockquote>
              2.1　概述</br>
              <details>
              <summary>2.2　运行时数据区域</summary>
                  <blockquote>
                  2.2.1　程序计数器</br>
                  2.2.2　java虚拟机栈</br>
                  2.2.3　本地方法栈</br>
                  2.2.4　java堆</br>
                  2.2.5　方法区</br>
                  2.2.6　运行时常量池</br>
                  2.2.7　直接内存</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.3　hotspot虚拟机对象探秘</summary>
                  <blockquote>
                  2.3.1　对象的创建</br>
                  2.3.2　对象的内存布局</br>
                  2.3.3　对象的访问定位</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.4　实战：outofmemoryerror异常</summary>
                  <blockquote>
                  2.4.1　java堆溢出</br>
                  2.4.2　虚拟机栈和本地方法栈溢出</br>
                  2.4.3　方法区和运行时常量池溢出</br>
                  2.4.4　本机直接内存溢出</br>
                  </blockquote>
              </details>
              2.5　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第3章　垃圾收集器与内存分配策略</summary>
              <blockquote>
              3.1　概述</br>
              <details>
              <summary>3.2　对象已死吗</summary>
                  <blockquote>
                  3.2.1　引用计数算法</br>
                  3.2.2　可达性分析算法</br>
                  3.2.3　再谈引用</br>
                  3.2.4　生存还是死亡</br>
                  3.2.5　回收方法区</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.3　垃圾收集算法</summary>
                  <blockquote>
                  3.3.1　标记-清除算法</br>
                  3.3.2　复制算法</br>
                  3.3.3　标记-整理算法</br>
                  3.3.4　分代收集算法</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.4　hotspot的算法实现</summary>
                  <blockquote>
                  3.4.1　枚举根节点</br>
                  3.4.2　安全点</br>
                  3.4.3　安全区域</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.5　垃圾收集器</summary>
                  <blockquote>
                  3.5.1　serial收集器</br>
                  3.5.2　parnew收集器</br>
                  3.5.3　parallel scavenge收集器</br>
                  3.5.4　serial old收集器</br>
                  3.5.5　parallel old收集器</br>
                  3.5.6　cms收集器</br>
                  3.5.7　g1收集器</br>
                  3.5.8　理解gc日志</br>
                  3.5.9　垃圾收集器参数总结</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.6　内存分配与回收策略</summary>
                  <blockquote>
                  3.6.1　对象优先在eden分配</br>
                  3.6.2　大对象直接进入老年代</br>
                  3.6.3　长期存活的对象将进入老年代</br>
                  3.6.4　动态对象年龄判定</br>
                  3.6.5　空间分配担保</br>
                  </blockquote>
              </details>
              3.7　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第4章　虚拟机性能监控与故障处理工具</summary>
              <blockquote>
              4.1　概述</br>
              <details>
              <summary>4.2　jdk的命令行工具</summary>
                  <blockquote>
                  4.2.1　jps：虚拟机进程状况工具</br>
                  4.2.2　jstat：虚拟机统计信息监视工具</br>
                  4.2.3　jinfo：java配置信息工具</br>
                  4.2.4　jmap：java内存映像工具</br>
                  4.2.5　jhat：虚拟机堆转储快照分析工具</br>
                  4.2.6　jstack：java堆栈跟踪工具</br>
                  4.2.7　hsdis：jit生成代码反汇编</br>
                  </blockquote>
              </details>
              <details>
              <summary>4.3　jdk的可视化工具</summary>
                  <blockquote>
                  4.3.1　jconsole：java监视与管理控制台</br>
                  4.3.2　visualvm：多合一故障处理工具</br>
                  </blockquote>
              </details>
              4.4　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第5章　调优案例分析与实战</summary>
              <blockquote>
              5.1　概述</br>
              <details>
              <summary>5.2　案例分析</summary>
                  <blockquote>
                  5.2.1　高性能硬件上的程序部署策略</br>
                  5.2.2　集群间同步导致的内存溢出</br>
                  5.2.3　堆外内存导致的溢出错误</br>
                  5.2.4　外部命令导致系统缓慢</br>
                  5.2.5　服务器jvm进程崩溃</br>
                  5.2.6　不恰当数据结构导致内存占用过大</br>
                  5.2.7　由windows虚拟内存导致的长时间停顿</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.3　实战：eclipse运行速度调优</summary>
                  <blockquote>
                  5.3.1　调优前的程序运行状态</br>
                  5.3.2　升级jdk 1.6的性能变化及兼容问题</br>
                  5.3.3　编译时间和类加载时间的优化</br>
                  5.3.4　调整内存设置控制垃圾收集频率</br>
                  5.3.5　选择收集器降低延迟</br>
                  </blockquote>
              </details>
              5.4　本章小结</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第三部分　虚拟机执行子系统</summary>
          <blockquote>
          <details>
          <summary>第6章　类文件结构</summary>
              <blockquote>
              6.1　概述</br>
              6.2　无关性的基石</br>
              <details>
              <summary>6.3　class类文件的结构</summary>
                  <blockquote>
                  6.3.1　魔数与class文件的版本</br>
                  6.3.2　常量池</br>
                  6.3.3　访问标志</br>
                  6.3.4　类索引、父类索引与接口索引集合</br>
                  6.3.5　字段表集合</br>
                  6.3.6　方法表集合</br>
                  6.3.7　属性表集合</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.4　字节码指令简介</summary>
                  <blockquote>
                  6.4.1　字节码与数据类型</br>
                  6.4.2　加载和存储指令</br>
                  6.4.3　运算指令</br>
                  6.4.4　类型转换指令</br>
                  6.4.5　对象创建与访问指令</br>
                  6.4.6　操作数栈管理指令</br>
                  6.4.7　控制转移指令</br>
                  6.4.8　方法调用和返回指令</br>
                  6.4.9　异常处理指令</br>
                  6.4.10　同步指令</br>
                  </blockquote>
              </details>
              6.5　公有设计和私有实现</br>
              6.6　class文件结构的发展</br>
              6.7　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第7章　虚拟机类加载机制</summary>
              <blockquote>
              7.1　概述</br>
              7.2　类加载的时机</br>
              <details>
              <summary>7.3　类加载的过程</summary>
                  <blockquote>
                  7.3.1　加载</br>
                  7.3.2　验证</br>
                  7.3.3　准备</br>
                  7.3.4　解析</br>
                  7.3.5　初始化</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.4　类加载器</summary>
                  <blockquote>
                  7.4.1　类与类加载器</br>
                  7.4.2　双亲委派模型</br>
                  7.4.3　破坏双亲委派模型</br>
                  </blockquote>
              </details>
              7.5　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第8章　虚拟机字节码执行引擎</summary>
              <blockquote>
              8.1　概述</br>
              <details>
              <summary>8.2　运行时栈帧结构</summary>
                  <blockquote>
                  8.2.1　局部变量表</br>
                  8.2.2　操作数栈</br>
                  8.2.3　动态连接</br>
                  8.2.4　方法返回地址</br>
                  8.2.5　附加信息</br>
                  </blockquote>
              </details>
              <details>
              <summary>8.3　方法调用</summary>
                  <blockquote>
                  8.3.1　解析</br>
                  8.3.2　分派</br>
                  8.3.3　动态类型语言支持</br>
                  </blockquote>
              </details>
              <details>
              <summary>8.4　基于栈的字节码解释执行引擎</summary>
                  <blockquote>
                  8.4.1　解释执行</br>
                  8.4.2　基于栈的指令集与基于寄存器的指令集</br>
                  8.4.3　基于栈的解释器执行过程</br>
                  </blockquote>
              </details>
              8.5　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第9章　类加载及执行子系统的案例与实战</summary>
              <blockquote>
              9.1　概述</br>
              <details>
              <summary>9.2　案例分析</summary>
                  <blockquote>
                  9.2.1　tomcat：正统的类加载器架构</br>
                  9.2.2　osgi：灵活的类加载器架构</br>
                  9.2.3　字节码生成技术与动态代理的实现</br>
                  9.2.4　retrotranslator：跨越jdk版本</br>
                  </blockquote>
              </details>
              <details>
              <summary>9.3　实战：自己动手实现远程执行功能</summary>
                  <blockquote>
                  9.3.1　目标</br>
                  9.3.2　思路</br>
                  9.3.3　实现</br>
                  9.3.4　验证</br>
                  </blockquote>
              </details>
              9.4　本章小结</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第四部分　程序编译与代码优化</summary>
          <blockquote>
          <details>
          <summary>第10章　早期（编译期）优化</summary>
              <blockquote>
              10.1　概述</br>
              <details>
              <summary>10.2　javac编译器</summary>
                  <blockquote>
                  10.2.1　javac的源码与调试</br>
                  10.2.2　解析与填充符号表</br>
                  10.2.3　注解处理器</br>
                  10.2.4　语义分析与字节码生成</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.3　java语法糖的味道</summary>
                  <blockquote>
                  10.3.1　泛型与类型擦除</br>
                  10.3.2　自动装箱、拆箱与遍历循环</br>
                  10.3.3　条件编译</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.4　实战：插入式注解处理器</summary>
                  <blockquote>
                  10.4.1　实战目标</br>
                  10.4.2　代码实现</br>
                  10.4.3　运行与测试</br>
                  10.4.4　其他应用案例</br>
                  </blockquote>
              </details>
              10.5　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第11章　晚期（运行期）优化</summary>
              <blockquote>
              11.1　概述</br>
              <details>
              <summary>11.2　hotspot虚拟机内的即时编译器</summary>
                  <blockquote>
                  11.2.1　解释器与编译器</br>
                  11.2.2　编译对象与触发条件</br>
                  11.2.3　编译过程</br>
                  11.2.4　查看及分析即时编译结果</br>
                  </blockquote>
              </details>
              <details>
              <summary>11.3　编译优化技术</summary>
                  <blockquote>
                  11.3.1　优化技术概览</br>
                  11.3.2　公共子表达式消除</br>
                  11.3.3　数组边界检查消除</br>
                  11.3.4　方法内联</br>
                  11.3.5　逃逸分析</br>
                  </blockquote>
              </details>
              11.4　java与cc++的编译器对比</br>
              11.5　本章小结</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第五部分　高效并发</summary>
          <blockquote>
          <details>
          <summary>第12章　java内存模型与线程</summary>
              <blockquote>
              12.1　概述</br>
              12.2　硬件的效率与一致性</br>
              <details>
              <summary>12.3　java内存模型</summary>
                  <blockquote>
                  12.3.1　主内存与工作内存</br>
                  12.3.2　内存间交互操作</br>
                  12.3.3　对于volatile型变量的特殊规则</br>
                  12.3.4　对于long和double型变量的特殊规则</br>
                  12.3.5　原子性、可见性与有序性</br>
                  12.3.6　先行发生原则</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.4　java与线程</summary>
                  <blockquote>
                  12.4.1　线程的实现</br>
                  12.4.2　java线程调度</br>
                  12.4.3　状态转换</br>
                  </blockquote>
              </details>
              12.5　本章小结</br>
              </blockquote>
          </details>
          <details>
          <summary>第13章　线程安全与锁优化</summary>
              <blockquote>
              13.1　概述</br>
              <details>
              <summary>13.2　线程安全</summary>
                  <blockquote>
                  13.2.1　java语言中的线程安全</br>
                  13.2.2　线程安全的实现方法</br>
                  </blockquote>
              </details>
              <details>
              <summary>13.3　锁优化</summary>
                  <blockquote>
                  13.3.1　自旋锁与自适应自旋</br>
                  13.3.2　锁消除</br>
                  13.3.3　锁粗化</br>
                  13.3.4　轻量级锁</br>
                  13.3.5　偏向锁</br>
                  </blockquote>
              </details>
              13.4　本章小结</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>附录</summary>
          <blockquote>
          附录a　编译windows版的openjdk</br>
          附录b　虚拟机字节码指令表</br>
          附录c　hotspot虚拟机主要参数表</br>
          附录d　对象查询语言（oql）简介</br>
          附录e　jdk历史版本轨迹</br>
          </blockquote>
      </details>
      </blockquote>
  </details></li>
<li>《Java并发编程实战》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章　简介1</summary>
          <blockquote>
          1.1　并发简史1</br>
          <details>
          <summary>1.2　线程的优势2</summary>
              <blockquote>
              1.2.1　发挥多处理器的强大能力2</br>
              1.2.2　建模的简单性3</br>
              1.2.3　异步事件的简化处理3</br>
              1.2.4　响应更灵敏的用户界面4</br>
              </blockquote>
          </details>
          <details>
          <summary>1.3　线程带来的风险4</summary>
              <blockquote>
              1.3.1　安全性问题5</br>
              1.3.2　活跃性问题7</br>
              1.3.3　性能问题7</br>
              </blockquote>
          </details>
          1.4　线程无处不在7</br>
          </blockquote>
      </details>
      <details>
      <summary>第一部分　基础知识</summary>
          <blockquote>
          <details>
          <summary>第2章　线程安全性11</summary>
              <blockquote>
              2.1　什么是线程安全性13</br>
              <details>
              <summary>2.2　原子性14</summary>
                  <blockquote>
                  2.2.1　竞态条件15</br>
                  2.2.2　示例：延迟初始化中的竞态条件16</br>
                  2.2.3　复合操作17</br>
                  </blockquote>
              </details>
              <details>
              <summary>2.3　加锁机制18</summary>
                  <blockquote>
                  2.3.1　内置锁20</br>
                  2.3.2　重入21</br>
                  </blockquote>
              </details>
              2.4　用锁来保护状态22</br>
              2.5　活跃性与性能23</br>
              </blockquote>
          </details>
          <details>
          <summary>第3章　对象的共享27</summary>
              <blockquote>
              <details>
              <summary>3.1　可见性27</summary>
                  <blockquote>
                  3.1.1　失效数据28</br>
                  3.1.2　非原子的64位操作29</br>
                  3.1.3　加锁与可见性30</br>
                  3.1.4　Volatile变量 30</br>
                  </blockquote>
              </details>
              3.2　发布与逸出32</br>
              <details>
              <summary>3.3　线程封闭35</summary>
                  <blockquote>
                  3.3.1　Ad-hoc线程封闭35</br>
                  3.3.2　栈封闭36</br>
                  3.3.3　ThreadLocal类37</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.4　不变性38</summary>
                  <blockquote>
                  3.4.1　Final域39</br>
                  3.4.2　示例：使用Volatile类型来发布不可变对象40</br>
                  </blockquote>
              </details>
              <details>
              <summary>3.5　安全发布41</summary>
                  <blockquote>
                  3.5.1　不正确的发布：正确的对象被破坏42</br>
                  3.5.2 　不可变对象与初始化安全性42</br>
                  3.5.3　安全发布的常用模式43</br>
                  3.5.4　事实不可变对象44</br>
                  3.5.5　可变对象44</br>
                  3.5.6　安全地共享对象44</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第4章　对象的组合46</summary>
              <blockquote>
              <details>
              <summary>4.1　设计线程安全的类46</summary>
                  <blockquote>
                  4.1.1　收集同步需求47</br>
                  4.1.2　依赖状态的操作48</br>
                  4.1.3　状态的所有权48</br>
                  </blockquote>
              </details>
              <details>
              <summary>4.2　实例封闭49</summary>
                  <blockquote>
                  4.2.1　Java监视器模式51</br>
                  4.2.2　示例：车辆追踪51</br>
                  </blockquote>
              </details>
              <details>
              <summary>4.3　线程安全性的委托53</summary>
                  <blockquote>
                  4.3.1　示例：基于委托的车辆追踪器54</br>
                  4.3.2　独立的状态变量55</br>
                  4.3.3　当委托失效时56</br>
                  4.3.4　发布底层的状态变量57</br>
                  4.3.5　示例：发布状态的车辆追踪器58</br>
                  </blockquote>
              </details>
              <details>
              <summary>4.4　在现有的线程安全类中添加功能59</summary>
                  <blockquote>
                  4.4.1　客户端加锁机制60</br>
                  4.4.2　组合62</br>
                  </blockquote>
              </details>
              4.5　将同步策略文档化62</br>
              </blockquote>
          </details>
          <details>
          <summary>第5章　基础构建模块66</summary>
              <blockquote>
              <details>
              <summary>5.1　同步容器类66</summary>
                  <blockquote>
                  5.1.1　同步容器类的问题66</br>
                  5.1.2　迭代器与Concurrent-ModificationException68</br>
                  5.1.3　隐藏迭代器69</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.2　并发容器70</summary>
                  <blockquote>
                  5.2.1　ConcurrentHashMap71</br>
                  5.2.2　额外的原子Map操作72</br>
                  5.2.3　CopyOnWriteArrayList72</br>
                  </blockquote>
              </details>
              <details>
              <summary>5.3　阻塞队列和生产者-消费者模式73</summary>
                  <blockquote>
                  5.3.1　示例：桌面搜索75</br>
                  5.3.2　串行线程封闭76</br>
                  5.3.3　双端队列与工作密取77</br>
                  </blockquote>
              </details>
              5.4　阻塞方法与中断方法77</br>
              <details>
              <summary>5.5　同步工具类78</summary>
                  <blockquote>
                  5.5.1　闭锁79</br>
                  5.5.2　FutureTask80</br>
                  5.5.3　信号量82</br>
                  5.5.4　栅栏83</br>
                  </blockquote>
              </details>
              5.6　构建高效且可伸缩的结果缓存85</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第二部分　结构化并发应用程序</summary>
          <blockquote>
          <details>
          <summary>第6章　任务执行93</summary>
              <blockquote>
              <details>
              <summary>6.1　在线程中执行任务93</summary>
                  <blockquote>
                  6.1.1　串行地执行任务94</br>
                  6.1.2　显式地为任务创建线程94</br>
                  6.1.3　无限制创建线程的不足95</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.2　Executor框架96</summary>
                  <blockquote>
                  6.2.1　示例：基于Executor的Web服务器97</br>
                  6.2.2　执行策略98</br>
                  6.2.3　线程池98</br>
                  6.2.4　Executor的生命周期99</br>
                  6.2.5　延迟任务与周期任务101</br>
                  </blockquote>
              </details>
              <details>
              <summary>6.3　找出可利用的并行性102</summary>
                  <blockquote>
                  6.3.1　示例：串行的页面渲染器102</br>
                  6.3.2　携带结果的任务Callable与Future103</br>
                  6.3.3　示例：使用Future实现页面渲染器104</br>
                  6.3.4　在异构任务并行化中存在的局限106</br>
                  6.3.5　CompletionService:Executor与BlockingQueue106</br>
                  6.3.6　示例：使用CompletionService实现页面渲染器107</br>
                  6.3.7　为任务设置时限108</br>
                  6.3.8　示例：旅行预定门户网站109</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第7章　取消与关闭111</summary>
              <blockquote>
              <details>
              <summary>7.1　任务取消111</summary>
                  <blockquote>
                  7.1.1　中断113</br>
                  7.1.2　中断策略116</br>
                  7.1.3　响应中断117</br>
                  7.1.4　示例：计时运行118</br>
                  7.1.5　通过Future来实现取消120</br>
                  7.1.6　处理不可中断的阻塞121</br>
                  7.1.7　采用newTaskFor来封装非标准的取消122</br>
                  </blockquote>
              </details>
              <details>
              <summary>7.2　停止基于线程的服务124</summary>
                  <blockquote>
                  7.2.1　示例：日志服务124</br>
                  7.2.2　关闭ExecutorService127</br>
                  7.2.3　“毒丸”对象128</br>
                  7.2.4　示例：只执行一次的服务129</br>
                  7.2.5　shutdownNow的局限性130</br>
                  </blockquote>
              </details>
              7.3　处理非正常的线程终止132</br>
              <details>
              <summary>7.4　JVM关闭135</summary>
                  <blockquote>
                  7.4.1　关闭钩子135</br>
                  7.4.2　守护线程136</br>
                  7.4.3　终结器136</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第8章　线程池的使用138</summary>
              <blockquote>
              <details>
              <summary>8.1　在任务与执行策略之间的隐性耦合138</summary>
                  <blockquote>
                  8.1.1　线程饥饿死锁139</br>
                  8.1.2　运行时间较长的任务140</br>
                  </blockquote>
              </details>
              8.2　设置线程池的大小140</br>
              <details>
              <summary>8.3　配置ThreadPoolExecutor141</summary>
                  <blockquote>
                  8.3.1　线程的创建与销毁142</br>
                  8.3.2　管理队列任务142</br>
                  8.3.3　饱和策略144</br>
                  8.3.4　线程工厂146</br>
                  8.3.5　在调用构造函数后再定制ThreadPoolExecutor147</br>
                  </blockquote>
              </details>
              8.4　扩展 ThreadPoolExecutor148</br>
              8.5　递归算法的并行化149</br>
              </blockquote>
          </details>
          <details>
          <summary>第9章　图形用户界面应用程序156</summary>
              <blockquote>
              <details>
              <summary>9.1　为什么GUI是单线程的156</summary>
                  <blockquote>
                  9.1.1　串行事件处理157</br>
                  9.1.2　Swing中的线程封闭机制158</br>
                  </blockquote>
              </details>
              9.2　短时间的GUI任务160</br>
              <details>
              <summary>9.3　长时间的GUI任务161</summary>
                  <blockquote>
                  9.3.1　取消162</br>
                  9.3.2　进度标识和完成标识163</br>
                  9.3.3　SwingWorker165</br>
                  </blockquote>
              </details>
              <details>
              <summary>9.4　共享数据模型165</summary>
                  <blockquote>
                  9.4.1　线程安全的数据模型166</br>
                  9.4.2　分解数据模型166</br>
                  </blockquote>
              </details>
              9.5　其他形式的单线程子系统167</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第三部分　活跃性、性能与测试</summary>
          <blockquote>
          <details>
          <summary>第10章　避免活跃性危险169</summary>
              <blockquote>
              <details>
              <summary>10.1　死锁169</summary>
                  <blockquote>
                  10.1.1　锁顺序死锁170</br>
                  10.1.2　动态的锁顺序死锁171</br>
                  10.1.3　在协作对象之间发生的死锁174</br>
                  10.1.4　开放调用175</br>
                  10.1.5　资源死锁177</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.2　死锁的避免与诊断178</summary>
                  <blockquote>
                  10.2.1　支持定时的锁178</br>
                  10.2.2　通过线程转储信息来分析死锁178</br>
                  </blockquote>
              </details>
              <details>
              <summary>10.3　其他活跃性危险180</summary>
                  <blockquote>
                  10.3.1　饥饿180</br>
                  10.3.2　糟糕的响应性181</br>
                  10.3.3　活锁181</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第11章　性能与可伸缩性183</summary>
              <blockquote>
              <details>
              <summary>11.1　对性能的思考183</summary>
                  <blockquote>
                  11.1.1　性能与可伸缩性184</br>
                  11.1.2　评估各种性能权衡因素185</br>
                  </blockquote>
              </details>
              <details>
              <summary>11.2　Amdahl定律186</summary>
                  <blockquote>
                  11.2.1　示例：在各种框架中隐藏的串行部分188</br>
                  11.2.2　Amdahl定律的应用189</br>
                  </blockquote>
              </details>
              <details>
              <summary>11.3　线程引入的开销189</summary>
                  <blockquote>
                  11.3.1　上下文切换190</br>
                  11.3.2　内存同步190</br>
                  11.3.3　阻塞192</br>
                  </blockquote>
              </details>
              <details>
              <summary>11.4　减少锁的竞争192</summary>
                  <blockquote>
                  11.4.1　缩小锁的范围（“快进快出”）193</br>
                  11.4.2　减小锁的粒度195</br>
                  11.4.3　锁分段196</br>
                  11.4.4　避免热点域197</br>
                  11.4.5　一些替代独占锁的方法198</br>
                  11.4.6　监测CPU的利用率199</br>
                  11.4.7　向对象池说“不”200</br>
                  </blockquote>
              </details>
              11.5　示例：比较Map的性能200</br>
              11.6　减少上下文切换的开销201</br>
              </blockquote>
          </details>
          <details>
          <summary>第12章　并发程序的测试204</summary>
              <blockquote>
              <details>
              <summary>12.1　正确性测试205</summary>
                  <blockquote>
                  12.1.1　基本的单元测试206</br>
                  12.1.2　对阻塞操作的测试207</br>
                  12.1.3　安全性测试208</br>
                  12.1.4　资源管理的测试212</br>
                  12.1.5　使用回调213</br>
                  12.1.6　产生更多的交替操作214</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.2　性能测试215</summary>
                  <blockquote>
                  12.2.1　在PutTakeTest中增加计时功能215</br>
                  12.2.2　多种算法的比较217</br>
                  12.2.3　响应性衡量218</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.3　避免性能测试的陷阱220</summary>
                  <blockquote>
                  12.3.1　垃圾回收220</br>
                  12.3.2　动态编译220</br>
                  12.3.3　对代码路径的不真实采样222</br>
                  12.3.4　不真实的竞争程度222</br>
                  12.3.5　无用代码的消除223</br>
                  </blockquote>
              </details>
              <details>
              <summary>12.4　其他的测试方法224</summary>
                  <blockquote>
                  12.4.1　代码审查224</br>
                  12.4.2　静态分析工具224</br>
                  12.4.3　面向方面的测试技术226</br>
                  12.4.4　分析与监测工具226</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          </blockquote>
      </details>
      <details>
      <summary>第四部分　高级主题</summary>
          <blockquote>
          <details>
          <summary>第13章　显式锁227</summary>
              <blockquote>
              <details>
              <summary>13.1　Lock与 ReentrantLock227</summary>
                  <blockquote>
                  13.1.1　轮询锁与定时锁228</br>
                  13.1.2　可中断的锁获取操作230</br>
                  13.1.3　非块结构的加锁231</br>
                  </blockquote>
              </details>
              13.2　性能考虑因素231</br>
              13.3　公平性232</br>
              13.4　在synchronized和ReentrantLock之间进行选择234</br>
              13.5　读-写锁235</br>
              </blockquote>
          </details>
          <details>
          <summary>第14章　构建自定义的同步工具238</summary>
              <blockquote>
              <details>
              <summary>14.1　状态依赖性的管理238</summary>
                  <blockquote>
                  14.1.1　示例：将前提条件的失败传递给调用者240</br>
                  14.1.2　示例：通过轮询与休眠来实现简单的阻塞241</br>
                  14.1.3　条件队列243</br>
                  </blockquote>
              </details>
              <details>
              <summary>14.2　使用条件队列244</summary>
                  <blockquote>
                  14.2.1　条件谓词244</br>
                  14.2.2　过早唤醒245</br>
                  14.2.3　丢失的信号246</br>
                  14.2.4　通知247</br>
                  14.2.5　示例：阀门类248</br>
                  14.2.6　子类的安全问题249</br>
                  14.2.7　封装条件队列250</br>
                  14.2.8　入口协议与出口协议250</br>
                  </blockquote>
              </details>
              14.3　显式的Condition对象251</br>
              14.4　Synchronizer剖析253</br>
              14.5　AbstractQueuedSynchronizer254</br>
              <details>
              <summary>14.6　java.util.concurrent同步器类中的 AQS257</summary>
                  <blockquote>
                  14.6.1　ReentrantLock257</br>
                  14.6.2　Semaphore与CountDownLatch258</br>
                  14.6.3　FutureTask259</br>
                  14.6.4　ReentrantReadWriteLock259</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第15章　原子变量与非阻塞同步机制261</summary>
              <blockquote>
              15.1　锁的劣势261</br>
              <details>
              <summary>15.2　硬件对并发的支持262</summary>
                  <blockquote>
                  15.2.1　比较并交换263</br>
                  15.2.2　非阻塞的计数器264</br>
                  15.2.3　JVM对CAS的支持265</br>
                  </blockquote>
              </details>
              <details>
              <summary>15.3　原子变量类265</summary>
                  <blockquote>
                  15.3.1　原子变量是一种“更好的volatile”266</br>
                  15.3.2　性能比较：锁与原子变量267</br>
                  </blockquote>
              </details>
              <details>
              <summary>15.4　非阻塞算法270</summary>
                  <blockquote>
                  15.4.1　非阻塞的栈270</br>
                  15.4.2　非阻塞的链表272</br>
                  15.4.3　原子的域更新器274</br>
                  15.4.4　ABA问题275</br>
                  </blockquote>
              </details>
              </blockquote>
          </details>
          <details>
          <summary>第16章　Java内存模型277</summary>
              <blockquote>
              <details>
              <summary>16.1　什么是内存模型，为什么需要它277</summary>
                  <blockquote>
                  16.1.1　平台的内存模型278</br>
                  16.1.2　重排序278</br>
                  16.1.3　Java内存模型简介280</br>
                  16.1.4　借助同步281</br>
                  </blockquote>
              </details>
              <details>
              <summary>16.2　发布283</summary>
                  <blockquote>
                  16.2.1　不安全的发布283</br>
                  16.2.2　安全的发布284</br>
                  16.2.3　安全初始化模式284</br>
                  16.2.4　双重检查加锁286</br>
                  </blockquote>
              </details>
              16.3　初始化过程中的安全性287</br>
              </blockquote>
          </details>
          </blockquote>
      </details>
      附录A　并发性标注289</br>
      参考文献291</br>
      </blockquote>
  </details></li>
<li>《Java多线程编程核心技术》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章 Java多线程技能，</summary>
          <blockquote>
          1.1 进程和多线程的概念及线程的优点</br>
          <details>
          <summary>1.2 使用多线程</summary>
              <blockquote>
              1.2.1 继承Thread类</br>
              1.2.2 实现Runnable接口</br>
              1.2.3 实例变量与线程安全</br>
              1.2.4 留意i——与System.out.println（）的异常</br>
              </blockquote>
          </details>
          1.3 currentThread（）方法</br>
          1.4 isAlive（）方法</br>
          1.5 sleep（）方法</br>
          1.6 getId（）方法</br>
          <details>
          <summary>1.7 停止线程</summary>
              <blockquote>
              1.7.1 停止不了的线程</br>
              1.7.2 判断线程是否是停止状态</br>
              1.7.3 能停止的线程——异常法</br>
              1.7.4 在沉睡中停止</br>
              1.7.5 能停止的线程——暴力停止</br>
              1.7.6 方法stop（）与java.lang.ThreadDeath异常</br>
              1.7.7 释放锁的不良后果</br>
              1.7.8 使用return停止线程</br>
              </blockquote>
          </details>
          <details>
          <summary>1.8 暂停线程</summary>
              <blockquote>
              1.8.1 suspend与resume方法的使用</br>
              1.8.2 suspend与resume方法的缺点——独占</br>
              1.8.3 suspend与resume方法的缺点——不同步</br>
              </blockquote>
          </details>
          1.9 yield方法</br>
          <details>
          <summary>1.10 线程的优先级</summary>
              <blockquote>
              1.10.1 线程优先级的继承特性</br>
              1.10.2 优先级具有规则性</br>
              1.10.3 优先级具有随机性</br>
              1.10.4 看谁运行得快</br>
              </blockquote>
          </details>
          1.11 守护线程</br>
          1.12 本章小结</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章 对象及变量的并发访问</summary>
          <blockquote>
          <details>
          <summary>2.1 synchronized同步方法</summary>
              <blockquote>
              2.1.1 方法内的变量为线程安全</br>
              2.1.2 实例变量非线程安全</br>
              2.1.3 多个对象多个锁</br>
              2.1.4 synchronized方法与锁对象</br>
              2.1.5 脏读</br>
              2.1.6 synchronized锁重入</br>
              2.1.7 出现异常，锁自动释放</br>
              2.1.8 同步不具有继承性</br>
              </blockquote>
          </details>
          <details>
          <summary>2.2 synchronized同步语句块</summary>
              <blockquote>
              2.2.1 synchronized方法的弊端</br>
              2.2.2 synchronized同步代码块的使用</br>
              2.2.3 用同步代码块解决同步方法的弊端</br>
              2.2.4 一半异步，一半同步</br>
              2.2.5 synchronized代码块间的同步性</br>
              2.2.6 验证同步synchronized（this）代码块是锁定当前对象的</br>
              2.2.7 将任意对象作为对象监视器</br>
              2.2.8 细化验证3个结论</br>
              2.2.9 静态同步synchronized方法与synchronized（class）代码块</br>
              2.2.10 数据类型String的常量池特性</br>
              2.2.11 同步synchronized方法无限等待与解决</br>
              2.2.12 多线程的死锁</br>
              2.2.13 内置类与静态内置类</br>
              2.2.14 内置类与同步：实验1</br>
              2.2.15 内置类与同步：实验2</br>
              2.2.16 锁对象的改变</br>
              </blockquote>
          </details>
          <details>
          <summary>2.3 volatile关键字</summary>
              <blockquote>
              2.3.1 关键字volatile与死循环</br>
              2.3.2 解决同步死循环</br>
              2.3.3 解决异步死循环</br>
              2.3.4 volatile非原子的特性</br>
              2.3.5 使用原子类进行i++操作</br>
              2.3.6 原子类也并不完全安全</br>
              2.3.7 synchronized代码块有volatile同步的功能</br>
              </blockquote>
          </details>
          2.4 本章总结</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章 线程间通信</summary>
          <blockquote>
          <details>
          <summary>3.1 等待/通知机制</summary>
              <blockquote>
              3.1.1 不使用等待/通知机制实现线程间通信</br>
              3.1.2 什么是等待/通知机制</br>
              3.1.3 等待/通知机制的实现</br>
              3.1.4 方法wait（）锁释放与notify（）锁不释放</br>
              3.1.5 当interrupt方法遇到wait方法</br>
              3.1.6 只通知一个线程</br>
              3.1.7 唤醒所有线程</br>
              3.1.8 方法wait（long）的使用</br>
              3.1.9 通知过早</br>
              3.1.10 等待wait的条件发生变化</br>
              3.1.11 生产者/消费者模式实现</br>
              3.1.12 通过管道进行线程间通信：字节流</br>
              3.1.13 通过管道进行线程间通信：字符流</br>
              3.1.14 实战：等待/通知之交叉备份</br>
              </blockquote>
          </details>
          <details>
          <summary>3.2 方法join的使用</summary>
              <blockquote>
              3.2.1 学习方法join前的铺垫</br>
              3.2.2 用join（）方法来解决</br>
              3.2.3 方法join与异常</br>
              3.2.4 方法join（long）的使用</br>
              3.2.5 方法join（long）与sleep（long）的区别</br>
              3.2.6 方法join（）后面的代码提前运行：出现意外</br>
              3.2.7 方法join（）后面的代码提前运行：解释意外</br>
              </blockquote>
          </details>
          <details>
          <summary>3.3 类ThreadLocal的使用</summary>
              <blockquote>
              3.3.1 方法get（）与null</br>
              3.3.2 验证线程变量的隔离性</br>
              3.3.3 解决get（）返回null问题</br>
              3.3.4 再次验证线程变量的隔离性</br>
              </blockquote>
          </details>
          <details>
          <summary>3.4 类InheritableThreadLocal的使用</summary>
              <blockquote>
              3.4.1 值继承</br>
              3.4.2 值继承再修改</br>
              </blockquote>
          </details>
          3.5 本章总结</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章 Lock的使用</summary>
          <blockquote>
          <details>
          <summary>4.1 使用ReentrantLock类</summary>
              <blockquote>
              4.1.1 使用ReentrantLock实现同步：测试1</br>
              4.1.2 使用ReentrantLock实现同步：测试2</br>
              4.1.3 使用Condition实现等待/通知错误用法与解决</br>
              4.1.4 正确使用Condition实现等待/通知</br>
              4.1.5 使用多个Condition实现通知部分线程：错误用法</br>
              4.1.6 使用多个Condition实现通知部分线程：正确用法</br>
              4.1.7 实现生产者/消费者模式：一对一交替打印</br>
              4.1.8 实现生产者/消费者模式：多对多交替打印</br>
              4.1.9 公平锁与非公平锁</br>
              4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试</br>
              4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试</br>
              4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试</br>
              4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试</br>
              4.1.14 方法awaitUninterruptibly（）的使用</br>
              4.1.15 方法awaitUntil（）的使用</br>
              4.1.16 使用Condition实现顺序执行</br>
              </blockquote>
          </details>
          <details>
          <summary>4.2 使用ReentrantReadWriteLock类</summary>
              <blockquote>
              4.2.1 类ReentrantReadWriteLock的使用：读读共享</br>
              4.2.2 类ReentrantReadWriteLock的使用：写写互斥</br>
              4.2.3 类ReentrantReadWriteLock的使用：读写互斥</br>
              4.2.4 类ReentrantReadWriteLock的使用：写读互斥</br>
              </blockquote>
          </details>
          4.3 本章总结</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章 定时器Timer</summary>
          <blockquote>
          <details>
          <summary>5.1 定时器Timer的使用</summary>
              <blockquote>
              5.1.1 方法schedule（TimerTask task， Date time）的测试</br>
              5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试</br>
              5.1.3 方法schedule（TimerTask task， long delay）的测试</br>
              5.1.4 方法schedule（TimerTask task， long delay， long period）的测试</br>
              5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试</br>
              </blockquote>
          </details>
          5.2 本章总结</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章 单例模式与多线程</summary>
          <blockquote>
          6.1 立即加载/"饿汉模式"</br>
          6.2 延迟加载/"懒汉模式"</br>
          6.3 使用静态内置类实现单例模式</br>
          6.4 序列化与反序列化的单例模式实现</br>
          6.5 使用static代码块实现单例模式</br>
          6.6 使用enum枚举数据类型实现单例模式</br>
          6.7 完善使用enum枚举实现单例模式</br>
          6.8 本章总结</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章 拾遗增补</summary>
          <blockquote>
          <details>
          <summary>7.1 线程的状态</summary>
              <blockquote>
              7.1.1 验证NEW、RUNNABLE和TERMINATED</br>
              7.1.2 验证TIMED_WAITING</br>
              7.1.3 验证BLOCKED</br>
              7.1.4 验证WAITING</br>
              </blockquote>
          </details>
          <details>
          <summary>7.2 线程组</summary>
              <blockquote>
              7.2.1 线程对象关联线程组：1级关联</br>
              7.2.2 线程对象关联线程组：多级关联</br>
              7.2.3 线程组自动归属特性</br>
              7.2.4 获取根线程组</br>
              7.2.5 线程组里加线程组</br>
              7.2.6 组内的线程批量停止</br>
              7.2.7 递归与非递归取得组内对象</br>
              </blockquote>
          </details>
          7.3 使线程具有有序性</br>
          <details>
          <summary>7.4 SimpleDateFormat非线程安全</summary>
              <blockquote>
              7.4.1 出现异常</br>
              7.4.2 解决异常方法1</br>
              7.4.3 解决异常方法2</br>
              </blockquote>
          </details>
          7.5 线程中出现异常的处理</br>
          7.6 线程组内处理异常</br>
          7.7 线程异常处理的传递</br>
          7.8 本章总结</br>
          </blockquote>
      </details>
      </blockquote>
  </details></li>
<li>《Java虚拟机规范——Java SE 8版》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章　引言1</summary>
          <blockquote>
          1.1　简史1</br>
          1.2　Java虚拟机2</br>
          1.3　各章节摘要2</br>
          1.4　说明3</br>
          1.5　反馈3</br>
          </blockquote>
      </details>
      <details>
      <summary>第2章　Java虚拟机结构4</summary>
          <blockquote>
          2.1　class文件格式4</br>
          2.2　数据类型5</br>
          <details>
          <summary>2.3　原始类型与值5</summary>
              <blockquote>
              2.3.1　整数类型与整型值6</br>
              2.3.2　浮点类型、取值集合及浮点值6</br>
              2.3.3　returnAddress类型和值8</br>
              2.3.4　boolean类型8</br>
              </blockquote>
          </details>
          2.4　引用类型与值9</br>
          <details>
          <summary>2.5　运行时数据区9</summary>
              <blockquote>
              2.5.1　pc寄存器9</br>
              2.5.2　Java虚拟机栈10</br>
              2.5.3　Java堆10</br>
              2.5.4　方法区11</br>
              2.5.5　运行时常量池11</br>
              2.5.6　本地方法栈12</br>
              </blockquote>
          </details>
          <details>
          <summary>2.6　栈帧12</summary>
              <blockquote>
              2.6.1　局部变量表13</br>
              2.6.2　操作数栈14</br>
              2.6.3　动态链接14</br>
              2.6.4　方法调用正常完成15</br>
              2.6.5　方法调用异常完成15</br>
              </blockquote>
          </details>
          2.7　对象的表示15</br>
          <details>
          <summary>2.8　浮点算法15</summary>
              <blockquote>
              2.8.1　Java虚拟机和IEEE 754中的浮点算法15</br>
              2.8.2　浮点模式16</br>
              2.8.3　数值集合转换17</br>
              </blockquote>
          </details>
          2.9　特殊方法18</br>
          2.10　异常19</br>
          <details>
          <summary>2.11　字节码指令集简介20</summary>
              <blockquote>
              2.11.1　数据类型与Java虚拟机21</br>
              2.11.2　加载和存储指令23</br>
              2.11.3　算术指令24</br>
              2.11.4　类型转换指令25</br>
              2.11.5　对象的创建与操作27</br>
              2.11.6　操作数栈管理指令27</br>
              2.11.7　控制转移指令27</br>
              2.11.8　方法调用和返回指令28</br>
              2.11.9　抛出异常28</br>
              2.11.10　同步28</br>
              </blockquote>
          </details>
          2.12　类库29</br>
          2.13　公有设计、私有实现30</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章　Java虚拟机编译器31</summary>
          <blockquote>
          3.1　示例的格式说明31</br>
          3.2　常量、局部变量和控制结构的使用32</br>
          3.3　算术运算36</br>
          3.4　访问运行时常量池36</br>
          3.5　与控制结构有关的更多示例37</br>
          3.6　接收参数40</br>
          3.7　方法调用41</br>
          3.8　使用类实例43</br>
          3.9　数组44</br>
          3.10　编译switch语句46</br>
          3.11　使用操作数栈48</br>
          3.12　抛出异常和处理异常48</br>
          3.13　编译finally语句块51</br>
          3.14　同步54</br>
          3.15　注解55</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章　class文件格式56</summary>
          <blockquote>
          4.1　ClassFile结构57</br>
          <details>
          <summary>4.2　各种名称的内部表示形式61</summary>
              <blockquote>
              4.2.1　类和接口的二进制名称61</br>
              4.2.2　非限定名61</br>
              </blockquote>
          </details>
          <details>
          <summary>4.3　描述符62</summary>
              <blockquote>
              4.3.1　语法符号62</br>
              4.3.2　字段描述符62</br>
              4.3.3　方法描述符63</br>
              </blockquote>
          </details>
          <details>
          <summary>4.4　常量池64</summary>
              <blockquote>
              4.4.1　CONSTANT_Class_info结构65</br>
              4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构66</br>
              4.4.3　CONSTANT_String_info结构67</br>
              4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构67</br>
              4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构68</br>
              4.4.6　CONSTANT_NameAnd-Type_info结构69</br>
              4.4.7　CONSTANT_Utf8_info结构70</br>
              4.4.8　CONSTANT_MethodHandle_info结构72</br>
              4.4.9　CONSTANT_MethodType_info结构73</br>
              4.4.10　CONSTANT_Invoke-Dynamic_info结构74</br>
              </blockquote>
          </details>
          4.5　字段74</br>
          4.6　方法76</br>
          <details>
          <summary>4.7　属性78</summary>
              <blockquote>
              4.7.1　自定义和命名新的属性82</br>
              4.7.2　ConstantValue属性82</br>
              4.7.3　Code属性83</br>
              4.7.4　StackMapTable属性86</br>
              4.7.5　Exceptions属性92</br>
              4.7.6　InnerClasses属性93</br>
              4.7.7　EnclosingMethod属性95</br>
              4.7.8　Synthetic属性96</br>
              4.7.9　Signature属性96</br>
              4.7.10　SourceFile属性100</br>
              4.7.11　SourceDebugExtension属性101</br>
              4.7.12　LineNumberTable属性102</br>
              4.7.13　LocalVariableTable属性103</br>
              4.7.14　LocalVariableTypeTable属性104</br>
              4.7.15　Deprecated属性106</br>
              4.7.16　RuntimeVisibleAnnota-tions属性106</br>
              4.7.17　RuntimeInvisible-Annotations属性110</br>
              4.7.18　RuntimeVisibleParameterAnnotations属性111</br>
              4.7.19　RuntimeInvisiblePara-meterAnnotations属性112</br>
              4.7.20　RuntimeVisibleTypeAnnotations属性114</br>
              4.7.21　RuntimeInvisibleType-Annotations属性124</br>
              4.7.22　AnnotationDefault属性125</br>
              4.7.23　BootstrapMethods属性126</br>
              4.7.24　MethodParameters属性127</br>
              </blockquote>
          </details>
          4.8　格式检查129</br>
          <details>
          <summary>4.9　Java虚拟机代码约束129</summary>
              <blockquote>
              4.9.1　静态约束130</br>
              4.9.2　结构化约束132</br>
              </blockquote>
          </details>
          <details>
          <summary>4.10　class文件校验135</summary>
              <blockquote>
              4.10.1　类型检查验证136</br>
              4.10.2　类型推导验证200</br>
              </blockquote>
          </details>
          4.11　Java虚拟机限制206</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章　加载、链接与初始化208</summary>
          <blockquote>
          5.1　运行时常量池208</br>
          5.2　虚拟机启动210</br>
          <details>
          <summary>5.3　创建和加载211</summary>
              <blockquote>
              5.3.1　使用引导类加载器来加载类型212</br>
              5.3.2　使用用户自定义类加载器来加载类型212</br>
              5.3.3　创建数组类213</br>
              5.3.4　加载限制214</br>
              5.3.5　从class文件表示得到类214</br>
              </blockquote>
          </details>
          <details>
          <summary>5.4　链接215</summary>
              <blockquote>
              5.4.1　验证216</br>
              5.4.2　准备216</br>
              5.4.3　解析217</br>
              5.4.4　访问控制225</br>
              5.4.5　方法覆盖225</br>
              </blockquote>
          </details>
          5.5　初始化226</br>
          5.6　绑定本地方法实现228</br>
          5.7　Java虚拟机退出228</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章　Java虚拟机指令集229</summary>
          <blockquote>
          6.1　设定：“必须”的含义229</br>
          6.2　保留操作码229</br>
          6.3　虚拟机错误230</br>
          6.4　指令描述格式230</br>
          6.5　指令集描述232</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章　操作码助记符320</summary>
          <blockquote>
          </blockquote>
      </details>
      附录A　Limited License Grant327</br>
      </blockquote>
  </details></li>
<li>《Effective Java》  <details>
  <summary>目录</summary>
      <blockquote>
      <details>
      <summary>第1章　引言 1</summary>
          <blockquote>
          </blockquote>
      </details>
      <details>
      <summary>第2章　创建和销毁对象 4</summary>
          <blockquote>
          第1条：用静态工厂方法代替构造器 4</br>
          第2条：遇到多个构造器参数时要考虑使用构建器 8</br>
          第3条：用私有构造器或者枚举类型强化Singleton属性 13</br>
          第4条：通过私有构造器强化不可实例化的能力 15</br>
          第5条：优先考虑依赖注入来引用资源 16</br>
          第6条：避免创建不必要的对象 18</br>
          第7条：消除过期的对象引用 20</br>
          第8条：避免使用终结方法和清除方法 23</br>
          第9条：try-with-resources优先于try-finally 27</br>
          </blockquote>
      </details>
      <details>
      <summary>第3章　对于所有对象都通用的方法 30</summary>
          <blockquote>
          第10条：覆盖equals时请遵守通用约定 30</br>
          第11条：覆盖equals时总要覆盖hashCode 40</br>
          第12条：始终要覆盖toString 44</br>
          第13条：谨慎地覆盖clone 46</br>
          第14条：考虑实现Comparable接口 53</br>
          </blockquote>
      </details>
      <details>
      <summary>第4章　类和接口 59</summary>
          <blockquote>
          第15条：使类和成员的可访问性最小化 59</br>
          第16条：要在公有类而非公有域中使用访问方法 62</br>
          第17条：使可变性最小化 64</br>
          第18条：复合优先于继承 70</br>
          第19条：要么设计继承并提供文档说明，要么禁止继承 75</br>
          第20条：接口优于抽象类 79</br>
          第21条：为后代设计接口 83</br>
          第22条：接口只用于定义类型 85</br>
          第23条：类层次优于标签类 86</br>
          第24条：静态成员类优于非静态成员类 88</br>
          第25条：限制源文件为单个顶级类 91</br>
          </blockquote>
      </details>
      <details>
      <summary>第5章　泛型 93</summary>
          <blockquote>
          第26条：请不要使用原生态类型 93</br>
          第27条：消除非受检的警告 97</br>
          第28条：列表优于数组 99</br>
          第29条：优先考虑泛型 102</br>
          第30条：优先考虑泛型方法 106</br>
          第31条：利用有限制通配符来提升API的灵活性 109</br>
          第32条：谨慎并用泛型和可变参数 114</br>
          第33条：优先考虑类型安全的异构容器 118</br>
          </blockquote>
      </details>
      <details>
      <summary>第6章　枚举和注解 123</summary>
          <blockquote>
          第34条：用enum代替int常量 123</br>
          第35条：用实例域代替序数 131</br>
          第36条：用EnumSet代替位域 132</br>
          第37条：用EnumMap代替序数索引 134</br>
          第38条：用接口模拟可扩展的枚举 138</br>
          第39条：注解优先于命名模式 140</br>
          第40条：坚持使用Override注解 147</br>
          第41条：用标记接口定义类型 149</br>
          </blockquote>
      </details>
      <details>
      <summary>第7章　Lambda和Stream 151</summary>
          <blockquote>
          第42条：Lambda优先于匿名类 151</br>
          第43条：方法引用优先于Lambda 154</br>
          第44条：坚持使用标准的函数接口 156</br>
          第45条：谨慎使用Stream 159</br>
          第46条：优先选择Stream中无副作用的函数 164</br>
          第47条：Stream要优先用Collection作为返回类型 168</br>
          第48条：谨慎使用Stream并行 172</br>
          </blockquote>
      </details>
      <details>
      <summary>第8章　方法 176</summary>
          <blockquote>
          第49条：检查参数的有效性 176</br>
          第50条：必要时进行保护性拷贝 179</br>
          第51条：谨慎设计方法签名 182</br>
          第52条：慎用重载 184</br>
          第53条：慎用可变参数 189</br>
          第54条：返回零长度的数组或者集合，而不是null 190</br>
          第55条：谨慎返回optinal 192</br>
          第56条：为所有导出的API元素编写文档注释 196</br>
          </blockquote>
      </details>
      <details>
      <summary>第9章　通用编程 202</summary>
          <blockquote>
          第57条：将局部变量的作用域最小化 202</br>
          第58条：for-each循环优先于传统的for循环 204</br>
          第59条：了解和使用类库 207</br>
          第60条：如果需要精确的答案，请避免使用float和double 209</br>
          第61条：基本类型优先于装箱基本类型 211</br>
          第62条：如果其他类型更适合，则尽量避免使用字符串 213</br>
          第63条：了解字符串连接的性能 215</br>
          第64条：通过接口引用对象 216</br>
          第65条：接口优先于反射机制 218</br>
          第66条：谨慎地使用本地方法 220</br>
          第67条：谨慎地进行优化 221</br>
          第68条：遵守普遍接受的命名惯例 223</br>
          </blockquote>
      </details>
      <details>
      <summary>第10章　异常 227</summary>
          <blockquote>
          第69条：只针对异常的情况才使用异常 227</br>
          第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 229</br>
          第71条：避免不必要地使用受检异常 231</br>
          第72条：优先使用标准的异常 232</br>
          第73条：抛出与抽象对应的异常 234</br>
          第74条：每个方法抛出的所有异常都要建立文档 235</br>
          第75条：在细节消息中包含失败-捕获信息 237</br>
          第76条：努力使失败保持原子性 238</br>
          第77条：不要忽略异常 239</br>
          </blockquote>
      </details>
      <details>
      <summary>第11章　并发 241</summary>
          <blockquote>
          第78条：同步访问共享的可变数据 241</br>
          第79条：避免过度同步 245</br>
          第80条：executor、task和stream优先于线程 250</br>
          第81条：并发工具优先于wait和notify 251</br>
          第82条：线程安全性的文档化 256</br>
          第83条：慎用延迟初始化 258</br>
          第84条：不要依赖于线程调度器 261</br>
          </blockquote>
      </details>
      <details>
      <summary>第12章　序列化 263</summary>
          <blockquote>
          第85条：其他方法优先于Java序列化 263</br>
          第86条：谨慎地实现Serializable接口 266</br>
          第87条：考虑使用自定义的序列化形式 269</br>
          第88条：保护性地编写readObject方法 274</br>
          第89条：对于实例控制，枚举类型优先于readResolve 279</br>
          第90条：考虑用序列化代理代替序列化实例 282</br>
          </blockquote>
      </details>
      附录　与第2版中条目的对应关系 286</br>
      参考文献 289</br>
      </blockquote>
  </details></li>
<li>《Java编程思想》</li>
<li>《NIO与Socket编程技术指南》</li>
<li>《Java网络编程》</li>
<li>《Java多线程编程实战指南——核心篇》</li>
<li>《Head First设计模式》</li>
<li>《大话设计模式》</li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li>《Android系统源代码情景分析》</li>
<li>《Android开发探索》</li>
<li>《第一行代码》</li>
<li>《Android编程权威指南》</li>
<li>《Android进阶之光》</li>
<li>《Android进阶解密》</li>
<li>《Android移动性能实战》</li>
<li>《Android框架揭秘——Inside the Android Framework》</li>
<li>《疯狂Android讲义》</li>
<li>《Android Gradle权威指南》</li>
<li>《Android源码设计模式解析与实战》</li>
<li>《Android自定义控件开发入门与实战》</li>
<li>《Android应用性能优化最佳实践》</li>
<li>《Android高级进阶》</li>
<li>《Android群英传》</li>
<li>《Android群英传——神兵利器》</li>
<li>《Android应用安全防护与逆向分析》</li>
<li>《精通Android网络开发》</li>
<li>《深入理解Android内核设计思想——上册》</li>
<li>《深入理解Android内核设计思想——下册》</li>
<li>《深入理解Android卷三》</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li>《嵌入式Linux操作系统原理与应用》</li>
<li>《鸟哥的Linux私房菜——基础学习篇》</li>
<li>《Linux系统编程》</li>
<li>《深入理解Linux内核》</li>
<li>《Linux内核设计与实现》</li>
</ul>
<h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><ul>
<li>《Kotlin实战》</li>
<li>《Kotlin极简教程》</li>
</ul>
<h2 id="Alogrithm-x2F-Data-structure"><a href="#Alogrithm-x2F-Data-structure" class="headerlink" title="Alogrithm&#x2F;Data structure"></a>Alogrithm&#x2F;Data structure</h2><ul>
<li>《数据结构——C语言版》</li>
<li>《数据结构与算法分析——C语言描述》</li>
<li>《算法设计与分析》—— 王红梅 胡明 编著</li>
<li>《程序员代码面试指南》</li>
<li>《剑指Offer》</li>
<li>《数据结构与算法分析——Java语言描述》</li>
<li>《算法竞赛入门经典》</li>
<li>《算法竞赛入门经典——习题与解答》</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>《图解HTTP》</li>
<li>《图解TCP&#x2F;IP》</li>
<li>《图解网络硬件》</li>
<li>《TCP&#x2F;IP详解 卷1:协议》</li>
<li>《计算机网络》</li>
</ul>
<h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><ul>
<li>《计算机组成原理》</li>
<li>《实用操作系统教程》</li>
<li>《计算机图形学》</li>
<li>《计算机图形学及其实践教程》</li>
<li>《数字图像处理》</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>《MySQL必知必会》</li>
<li>《SQL基础教程》</li>
<li>《Oracle从入门到精通》</li>
<li>《数据库原理与应用》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>《汇编语言》</li>
<li>《Servlet、JSP和Spring MVC初学指南》</li>
<li>《基于Material Design的Android用户界面设计》</li>
<li>《Android项目开发｜实战入门》</li>
<li>《Android精彩编程200例》</li>
<li>《实战Gradle》</li>
<li>《JavaScript DOM编程艺术》</li>
<li>《微信公众平台开发最佳实践》</li>
<li>《代码整洁之道 程序员的职业素养》</li>
<li>《代码整洁之道 Clean Code》</li>
<li>《App后台开发运维和架构实践》</li>
<li>《App研发录——架构设计、Crash分析和竞品技术分析》</li>
<li>《单片机原理及应用——基于Proteus和Keil C》</li>
<li>《数字电子技术基础》</li>
<li>《Head First HTML与CSS》</li>
</ul>
</div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://example.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/head_picture.jpeg"/></a><p>路漫漫其修远兮，吾将上下而求索。</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:wangzhengtai@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/wangzhengtai" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Alogrithm/">Alogrithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hello-World/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hello-World/" style="font-size: 15px;">Hello World</a> <a href="/tags/Code/" style="font-size: 15px;">Code</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/" style="font-size: 15px;">程序员代码面试指南</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/04/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/">程序员代码面试指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/10/%E7%9B%AE%E5%BD%95%E8%BD%AC%E6%8D%A2%E7%A8%8B%E5%BA%8F/">目录转换程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/07/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/">代码记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/06/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">落叶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>